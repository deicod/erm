package generator

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"github.com/deicod/erm/orm/dsl"
)

const (
	annotationNullableGoType = "nullable_go_type"
	nullableStrategyPointer  = "pointer"
	nullableStrategySQLNull  = "sql_null"
)

func writeORMArtifacts(root string, entities []Entity) error {
	if err := writeRegistry(root, entities); err != nil {
		return err
	}
	if err := writeModels(root, entities); err != nil {
		return err
	}
	if err := writeClients(root, entities); err != nil {
		return err
	}
	return nil
}

func writeRegistry(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")
	fmt.Fprintf(buf, "import (\n    \"github.com/deicod/erm/orm/dsl\"\n    \"github.com/deicod/erm/orm/runtime\"\n)\n\n")
	fmt.Fprintf(buf, "var Registry = runtime.Registry{\n    Entities: map[string]runtime.EntitySpec{\n")
	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "        \"%s\": {\n", ent.Name)
		fmt.Fprintf(buf, "            Name: \"%s\",\n", ent.Name)
		fmt.Fprintf(buf, "            Table: \"%s\",\n", pluralize(ent.Name))
		fmt.Fprintf(buf, "            Fields: []runtime.FieldSpec{\n")
		for _, field := range ent.Fields {
			goType := defaultGoType(field)
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, GoType: %q, Type: %s, Primary: %t, Nullable: %t, Unique: %t, DefaultNow: %t, UpdateNow: %t, DefaultExpr: %q, ReadOnly: %t, ComputedSpec: %s, Annotations: %s, EnumValues: %s, EnumName: %q},\n",
				field.Name, fieldColumn(field), goType, fieldTypeLiteral(field.Type), field.IsPrimary, field.Nullable, field.IsUnique, field.HasDefaultNow, field.HasUpdateNow, field.DefaultExpr, field.ReadOnly || field.ComputedSpec != nil, computedLiteral(field.ComputedSpec), mapLiteral(field.Annotations), quoteStringSlice(field.EnumValues), field.EnumName)
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Edges: []runtime.EdgeSpec{\n")
		for _, edge := range ent.Edges {
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, RefName: %q, Through: %q, Target: %q, Kind: %s, Nullable: %t, Unique: %t, Annotations: %s, Inverse: %q, PolymorphicTargets: %s, Cascade: %s},\n",
				edge.Name, edgeColumn(edge), edge.RefName, edge.Through, edge.Target, edgeKindLiteral(edge.Kind), edge.Nullable, edge.Unique, mapLiteral(edge.Annotations), edge.InverseName, edgeTargetsLiteral(edge.PolymorphicTargets), edgeCascadeLiteral(edge.Cascade))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Indexes: []runtime.IndexSpec{\n")
		for _, idx := range ent.Indexes {
			fmt.Fprintf(buf, "                {Name: %q, Columns: %s, Unique: %t, Where: %q, Method: %q, NullsNotDistinct: %t, Annotations: %s},\n",
				idx.Name, quoteStringSlice(idx.Columns), idx.IsUnique, idx.Where, idx.Method, idx.NullsNotDistinct, mapLiteral(idx.Annotations))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "        },\n")
	}
	fmt.Fprintf(buf, "    },\n}\n")
	path := filepath.Join(root, "orm", "gen", "registry_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func writeModels(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	imports := collectModelImports(entities)
	if len(imports) > 0 {
		fmt.Fprintf(buf, "import (\n")
		sort.Strings(imports)
		for _, imp := range imports {
			fmt.Fprintf(buf, "    \"%s\"\n", imp)
		}
		fmt.Fprintf(buf, ")\n\n")
	}

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "type %s struct {\n", ent.Name)
		for _, field := range ent.Fields {
			goType := defaultGoType(field)
			dbTag := fieldColumn(field)
			jsonTag := jsonName(field.Name)
			if field.Nullable {
				dbTag += ",omitempty"
				jsonTag += ",omitempty"
			}
			fmt.Fprintf(buf, "    %s %s `db:\"%s\" json:\"%s\"`\n", exportName(field.Name), goType, dbTag, jsonTag)
		}
		if len(ent.Edges) > 0 {
			fmt.Fprintf(buf, "    Edges *%sEdges `json:\"edges,omitempty\"`\n", ent.Name)
		}
		fmt.Fprintf(buf, "}\n\n")

		if len(ent.Edges) > 0 {
			emitEdgesStruct(buf, ent)
			emitEdgeAccessors(buf, ent)
		}
	}

	path := filepath.Join(root, "orm", "gen", "models_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func fieldColumn(field dsl.Field) string {
	if field.Column != "" {
		return field.Column
	}
	return toSnakeCase(field.Name)
}

func edgeColumn(edge dsl.Edge) string {
	if edge.Column != "" {
		return edge.Column
	}
	switch edge.Kind {
	case dsl.EdgeToOne:
		return toSnakeCase(edge.Name) + "_id"
	default:
		return toSnakeCase(edge.Name)
	}
}

func jsonName(name string) string {
	out := toSnakeCase(name)
	if out == "" {
		return name
	}
	return out
}

func quoteStringSlice(items []string) string {
	if len(items) == 0 {
		return "nil"
	}
	parts := make([]string, len(items))
	for i, item := range items {
		parts[i] = fmt.Sprintf("\"%s\"", item)
	}
	return fmt.Sprintf("[]string{%s}", strings.Join(parts, ", "))
}

func defaultGoType(field dsl.Field) string {
	base := baseGoType(field)
	if !field.Nullable {
		return base
	}
	strategy := nullableGoStrategy(field)
	if strategy == nullableStrategySQLNull {
		if sqlType := sqlNullType(field); sqlType != "" {
			return sqlType
		}
	}
	if strings.HasPrefix(base, "*") || strings.HasPrefix(base, "sql.Null") {
		return base
	}
	if strings.HasPrefix(base, "[]") || strings.HasPrefix(base, "map[") {
		return base
	}
	return "*" + base
}

func baseGoType(field dsl.Field) string {
	if field.GoType != "" {
		return field.GoType
	}
	switch field.Type {
	case dsl.TypeUUID:
		return "string"
	case dsl.TypeEnum:
		return "string"
	case dsl.TypeText, dsl.TypeVarChar, dsl.TypeChar, dsl.TypeXML,
		dsl.TypeInet, dsl.TypeCIDR, dsl.TypeMACAddr, dsl.TypeMACAddr8,
		dsl.TypeBit, dsl.TypeVarBit, dsl.TypeTSVector, dsl.TypeTSQuery,
		dsl.TypePoint, dsl.TypeLine, dsl.TypeLseg, dsl.TypeBox, dsl.TypePath,
		dsl.TypePolygon, dsl.TypeCircle, dsl.TypeInt4Range, dsl.TypeInt8Range,
		dsl.TypeNumRange, dsl.TypeTSRange, dsl.TypeTSTZRange, dsl.TypeDateRange,
		dsl.TypeMoney, dsl.TypeInterval:
		return "string"
	case dsl.TypeBoolean:
		return "bool"
	case dsl.TypeSmallInt, dsl.TypeSmallSerial:
		return "int16"
	case dsl.TypeInteger, dsl.TypeSerial:
		return "int32"
	case dsl.TypeBigInt, dsl.TypeBigSerial:
		return "int64"
	case dsl.TypeDecimal, dsl.TypeNumeric:
		return "string"
	case dsl.TypeReal:
		return "float32"
	case dsl.TypeDoublePrecision:
		return "float64"
	case dsl.TypeBytea:
		return "[]byte"
	case dsl.TypeDate, dsl.TypeTime, dsl.TypeTimeTZ, dsl.TypeTimestamp, dsl.TypeTimestampTZ:
		return "time.Time"
	case dsl.TypeJSON, dsl.TypeJSONB:
		return "json.RawMessage"
	case dsl.TypeGeometry, dsl.TypeGeography:
		return "[]byte"
	case dsl.TypeVector:
		return "[]float32"
	case dsl.TypeArray:
		elemType, _ := field.Annotations["array_element"].(dsl.FieldType)
		if elemType == "" {
			return "[]string"
		}
		elemField := dsl.Field{Type: elemType}
		elemGo := defaultGoType(elemField)
		if elemGo == "" {
			return "[]any"
		}
		if strings.HasPrefix(elemGo, "[]") {
			return "[]" + elemGo
		}
		return "[]" + elemGo
	default:
		return "string"
	}
}

func nullableGoStrategy(field dsl.Field) string {
	if field.Annotations != nil {
		if raw, ok := field.Annotations[annotationNullableGoType]; ok {
			if val, ok := raw.(string); ok && val != "" {
				switch val {
				case nullableStrategySQLNull:
					return nullableStrategySQLNull
				case nullableStrategyPointer:
					return nullableStrategyPointer
				}
			}
		}
	}
	return nullableStrategyPointer
}

func sqlNullType(field dsl.Field) string {
	switch field.Type {
	case dsl.TypeBoolean:
		return "sql.NullBool"
	case dsl.TypeSmallInt, dsl.TypeSmallSerial:
		return "sql.NullInt16"
	case dsl.TypeInteger, dsl.TypeSerial:
		return "sql.NullInt32"
	case dsl.TypeBigInt, dsl.TypeBigSerial:
		return "sql.NullInt64"
	case dsl.TypeReal, dsl.TypeDoublePrecision, dsl.TypeDecimal, dsl.TypeNumeric:
		return "sql.NullFloat64"
	case dsl.TypeDate, dsl.TypeTime, dsl.TypeTimeTZ, dsl.TypeTimestamp, dsl.TypeTimestampTZ:
		return "sql.NullTime"
	case dsl.TypeUUID, dsl.TypeText, dsl.TypeVarChar, dsl.TypeChar, dsl.TypeXML,
		dsl.TypeInet, dsl.TypeCIDR, dsl.TypeMACAddr, dsl.TypeMACAddr8,
		dsl.TypeBit, dsl.TypeVarBit, dsl.TypeTSVector, dsl.TypeTSQuery,
		dsl.TypePoint, dsl.TypeLine, dsl.TypeLseg, dsl.TypeBox, dsl.TypePath,
		dsl.TypePolygon, dsl.TypeCircle, dsl.TypeInt4Range, dsl.TypeInt8Range,
		dsl.TypeNumRange, dsl.TypeTSRange, dsl.TypeTSTZRange, dsl.TypeDateRange,
		dsl.TypeMoney, dsl.TypeInterval, dsl.TypeJSON, dsl.TypeJSONB,
		dsl.TypeGeometry, dsl.TypeGeography:
		return "sql.NullString"
	default:
		return ""
	}
}

func collectModelImports(entities []Entity) []string {
	set := map[string]struct{}{}
	for _, ent := range entities {
		for _, field := range ent.Fields {
			goType := defaultGoType(field)
			switch {
			case goType == "time.Time" || goType == "*time.Time":
				set["time"] = struct{}{}
			case goType == "json.RawMessage" || goType == "*json.RawMessage":
				set["encoding/json"] = struct{}{}
			case strings.HasPrefix(goType, "sql.Null"):
				set["database/sql"] = struct{}{}
				if goType == "sql.NullTime" {
					set["time"] = struct{}{}
				}
			}
		}
	}
	imports := make([]string, 0, len(set))
	for imp := range set {
		imports = append(imports, imp)
	}
	return imports
}

func writeClients(root string, entities []Entity) error {
	path := filepath.Join(root, "orm", "gen", "client_gen.go")
	if len(entities) == 0 {
		src := []byte("// Code generated by erm. DO NOT EDIT.\npackage gen\n")
		return writeGoFile(path, src)
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	needsTime := false
	needsID := false
	hasEdges := false
	for _, ent := range entities {
		for _, field := range ent.Fields {
			if field.HasDefaultNow || field.HasUpdateNow {
				needsTime = true
			}
			if field.IsPrimary && field.Type == dsl.TypeUUID {
				needsID = true
			}
		}
		if len(ent.Edges) > 0 {
			hasEdges = true
		}
	}

	imports := []string{"context", "errors", "fmt"}
	if hasEdges {
		imports = append(imports, "strings")
	}
	if needsTime {
		imports = append(imports, "time")
	}
	imports = append(imports,
		"github.com/jackc/pgx/v5",
		"github.com/deicod/erm/orm/pg",
		"github.com/deicod/erm/orm/runtime",
		"github.com/deicod/erm/orm/runtime/cache",
		"github.com/deicod/erm/orm/runtime/validation",
	)
	if needsID {
		imports = append(imports, "github.com/deicod/erm/orm/id")
	}

	sort.Strings(imports)
	fmt.Fprintf(buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(buf, "    \"%s\"\n", imp)
	}
	fmt.Fprintf(buf, ")\n\n")

	fmt.Fprintf(buf, "var ValidationRegistry = validation.NewRegistry()\n\n")

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })

	fmt.Fprintf(buf, "type Client struct {\n    db *pg.DB\n    cache cache.Store\n}\n\n")
	fmt.Fprintf(buf, "func NewClient(db *pg.DB) *Client {\n    return &Client{db: db, cache: cache.Nop()}\n}\n\n")
	fmt.Fprintf(buf, "func (c *Client) UseCache(store cache.Store) {\n")
	fmt.Fprintf(buf, "    if c == nil {\n        return\n    }\n")
	fmt.Fprintf(buf, "    if store == nil {\n        store = cache.Nop()\n    }\n")
	fmt.Fprintf(buf, "    c.cache = store\n}\n\n")
	fmt.Fprintf(buf, "func (c *Client) cacheStore() cache.Store {\n")
	fmt.Fprintf(buf, "    if c == nil || c.cache == nil {\n        return cache.Nop()\n    }\n")
	fmt.Fprintf(buf, "    return c.cache\n}\n\n")
	fmt.Fprintf(buf, "func makeCacheKey(entity string, id any) string {\n    return \"orm:\" + entity + \":\" + fmt.Sprint(id)\n}\n\n")

	entityIndex := make(map[string]Entity, len(entities))
	for _, ent := range entities {
		entityIndex[ent.Name] = ent
	}

	for _, ent := range entities {
		fmt.Fprintf(buf, "func (c *Client) %s() *%sClient {\n    return &%sClient{db: c.db, cache: c.cacheStore()}\n}\n\n", exportName(pluralize(ent.Name)), ent.Name, ent.Name)
	}

	for _, ent := range entities {
		emitEntityClients(buf, ent, entityIndex)
	}

	for _, ent := range entities {
		emitValidationRecordHelper(buf, ent)
	}

	if hasEdges {
		emitRelationshipHelpers(buf)
	}

	return writeGoFile(path, buf.Bytes())
}

func emitEntityClients(buf *bytes.Buffer, ent Entity, entityIndex map[string]Entity) {
	name := ent.Name
	lower := strings.ToLower(name)
	columns := entityColumns(ent)
	returning := strings.Join(columns, ", ")
	insertCols := insertColumns(ent)
	var insertSQL string
	if len(insertCols) == 0 {
		insertSQL = fmt.Sprintf("INSERT INTO %s DEFAULT VALUES RETURNING %s", pluralize(name), returning)
	} else {
		insertSQL = fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", pluralize(name), strings.Join(insertCols, ", "), placeholders(len(insertCols)), returning)
	}
	selectSQL := fmt.Sprintf("SELECT %s FROM %s WHERE %s = $1", returning, pluralize(name), primaryColumn(ent))
	listSQL := fmt.Sprintf("SELECT %s FROM %s ORDER BY %s LIMIT $1 OFFSET $2", returning, pluralize(name), primaryColumn(ent))
	countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s", pluralize(name))

	updateCols := updatableColumns(ent)
	updateSQL := ""
	if len(updateCols) > 0 {
		assignments := make([]string, len(updateCols))
		for i, col := range updateCols {
			assignments[i] = fmt.Sprintf("%s = $%d", col, i+1)
		}
		updateSQL = fmt.Sprintf("UPDATE %s SET %s WHERE %s = $%d RETURNING %s", pluralize(name), strings.Join(assignments, ", "), primaryColumn(ent), len(updateCols)+1, returning)
	}

	fmt.Fprintf(buf, "const %sInsertQuery = `%s`\n", lower, insertSQL)
	fmt.Fprintf(buf, "const %sSelectQuery = `%s`\n", lower, selectSQL)
	fmt.Fprintf(buf, "const %sListQuery = `%s`\n", lower, listSQL)
	if updateSQL != "" {
		fmt.Fprintf(buf, "const %sUpdateQuery = `%s`\n", lower, updateSQL)
	}
	fmt.Fprintf(buf, "const %sCountQuery = `%s`\n", lower, countSQL)
	fmt.Fprintf(buf, "const %sDeleteQuery = `DELETE FROM %s WHERE %s = $1`\n\n", lower, pluralize(name), primaryColumn(ent))

	fmt.Fprintf(buf, "type %sClient struct {\n    db *pg.DB\n    cache cache.Store\n}\n\n", name)

	emitCreateMethod(buf, ent)
	emitBulkCreateMethod(buf, ent)
	emitByIDMethod(buf, ent)
	emitListMethod(buf, ent)
	emitCountMethod(buf, ent)
	if updateSQL != "" {
		emitUpdateMethod(buf, ent)
		emitBulkUpdateMethod(buf, ent, updateCols)
	}
	emitDeleteMethod(buf, ent)
	emitBulkDeleteMethod(buf, ent)
	emitQueryBuilder(buf, ent)
	emitEdgeLoaders(buf, ent, entityIndex)
}

func emitCreateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Create(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")

	computed := computedFields(ent)
	if len(computed) > 0 {
		for _, field := range computed {
			fmt.Fprintf(buf, "    if !runtime.IsZeroValue(input.%s) {\n", exportName(field.Name))
			fmt.Fprintf(buf, "        return nil, fmt.Errorf(\"%s.%s is computed and cannot be set\")\n    }\n", ent.Name, exportName(field.Name))
		}
	}

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasDefaultNow || field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}

	for _, field := range ent.Fields {
		fieldName := exportName(field.Name)
		switch {
		case field.IsPrimary && field.Type == dsl.TypeUUID:
			fmt.Fprintf(buf, "    if input.%s == \"\" {\n", fieldName)
			fmt.Fprintf(buf, "        v, err := id.NewV7()\n")
			fmt.Fprintf(buf, "        if err != nil { return nil, err }\n")
			fmt.Fprintf(buf, "        input.%s = v\n", fieldName)
			fmt.Fprintf(buf, "    }\n")
		}
		if field.HasDefaultNow {
			fmt.Fprintf(buf, "    if input.%s.IsZero() { input.%s = now }\n", fieldName, fieldName)
		}
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", fieldName)
		}
	}

	fmt.Fprintf(buf, "    if err := ValidationRegistry.Validate(ctx, %q, validation.OpCreate, %sValidationRecord(input), input); err != nil {\n        return nil, err\n    }\n", ent.Name, strings.ToLower(ent.Name))

	insertFields := insertableFields(ent)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sInsertQuery", strings.ToLower(ent.Name))
	for _, field := range insertFields {
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ")\n")
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    if c.cache != nil {\n        _ = c.cache.Set(ctx, makeCacheKey(%q, out.%s), out)\n    }\n", ent.Name, exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitBulkCreateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) BulkCreate(ctx context.Context, inputs []*%s) ([]*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if len(inputs) == 0 {\n        return []*%s{}, nil\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    rowsSpec := make([][]any, 0, len(inputs))\n")
	computed := computedFields(ent)
	needsNow := false
	for _, field := range ent.Fields {
		if field.HasDefaultNow || field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	fmt.Fprintf(buf, "    for _, input := range inputs {\n")
	fmt.Fprintf(buf, "        if input == nil {\n            return nil, errors.New(\"input cannot be nil\")\n        }\n")
	if needsNow {
		fmt.Fprintf(buf, "        now := time.Now().UTC()\n")
	}
	if len(computed) > 0 {
		for _, field := range computed {
			fmt.Fprintf(buf, "        if !runtime.IsZeroValue(input.%s) {\n", exportName(field.Name))
			fmt.Fprintf(buf, "            return nil, fmt.Errorf(\"%s.%s is computed and cannot be set\")\n        }\n", ent.Name, exportName(field.Name))
		}
	}
	for _, field := range ent.Fields {
		fieldName := exportName(field.Name)
		switch {
		case field.IsPrimary && field.Type == dsl.TypeUUID:
			fmt.Fprintf(buf, "        if input.%s == \"\" {\n", fieldName)
			fmt.Fprintf(buf, "            v, err := id.NewV7()\n")
			fmt.Fprintf(buf, "            if err != nil { return nil, err }\n")
			fmt.Fprintf(buf, "            input.%s = v\n", fieldName)
			fmt.Fprintf(buf, "        }\n")
		}
		if field.HasDefaultNow {
			fmt.Fprintf(buf, "        if input.%s.IsZero() { input.%s = now }\n", fieldName, fieldName)
		}
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "        input.%s = now\n", fieldName)
		}
	}
	fmt.Fprintf(buf, "        if err := ValidationRegistry.Validate(ctx, %q, validation.OpCreate, %sValidationRecord(input), input); err != nil {\n            return nil, err\n        }\n", ent.Name, strings.ToLower(ent.Name))
	insertFields := insertableFields(ent)
	if len(insertFields) == 0 {
		fmt.Fprintf(buf, "        row := []any{}\n")
	} else {
		fmt.Fprintf(buf, "        row := []any{")
		for i, field := range insertFields {
			if i > 0 {
				fmt.Fprintf(buf, ", ")
			}
			fmt.Fprintf(buf, "input.%s", exportName(field.Name))
		}
		fmt.Fprintf(buf, "}\n")
	}
	fmt.Fprintf(buf, "        rowsSpec = append(rowsSpec, row)\n")
	fmt.Fprintf(buf, "    }\n")
	columns := entityColumns(ent)
	insertCols := insertColumns(ent)
	fmt.Fprintf(buf, "    spec := runtime.BulkInsertSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        Columns: %s,\n", quoteStringSlice(insertCols))
	fmt.Fprintf(buf, "        Returning: %s,\n", quoteStringSlice(columns))
	fmt.Fprintf(buf, "        Rows: rowsSpec,\n")
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    sql, args, err := runtime.BuildBulkInsertSQL(spec)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var created []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n")
	fmt.Fprintf(buf, "        item := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "        if err := rows.Scan(%s); err != nil {\n            return nil, err\n        }\n", scanArgs(ent))
	fmt.Fprintf(buf, "        created = append(created, item)\n")
	fmt.Fprintf(buf, "        if c.cache != nil {\n            _ = c.cache.Set(ctx, makeCacheKey(%q, item.%s), item)\n        }\n", ent.Name, exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return created, nil\n}\n\n")
}

func emitByIDMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) ByID(ctx context.Context, id string) (*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    var cachedKey string\n")
	fmt.Fprintf(buf, "    if c.cache != nil {\n")
	fmt.Fprintf(buf, "        cachedKey = makeCacheKey(%q, id)\n", ent.Name)
	fmt.Fprintf(buf, "        if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {\n            return nil, err\n        } else if ok {\n            if entity, ok := value.(*%s); ok {\n                return entity, nil\n            }\n        }\n", ent.Name)
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sSelectQuery, id)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        if errors.Is(err, pgx.ErrNoRows) {\n            return nil, nil\n        }\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    if c.cache != nil {\n        cachedKey = makeCacheKey(%q, out.%s)\n        _ = c.cache.Set(ctx, cachedKey, out)\n    }\n", ent.Name, exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitListMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) List(ctx context.Context, limit, offset int) ([]*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if limit <= 0 { limit = 20 }\n")
	fmt.Fprintf(buf, "    if offset < 0 { offset = 0 }\n")
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, %sListQuery, limit, offset)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    if err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var result []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(", ent.Name)
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&item.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n            return nil, err\n        }\n        result = append(result, item)\n    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    return result, nil\n}\n\n")
}

func emitCountMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Count(ctx context.Context) (int, error) {\n", ent.Name)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sCountQuery)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    var total int\n")
	fmt.Fprintf(buf, "    if err := row.Scan(&total); err != nil {\n        return 0, err\n    }\n")
	fmt.Fprintf(buf, "    return total, nil\n}\n\n")
}

func emitUpdateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Update(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")
	fmt.Fprintf(buf, "    if input.%s == \"\" {\n        return nil, errors.New(\"id is required\")\n    }\n", exportName(primaryField(ent).Name))

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", exportName(field.Name))
		}
	}

	fmt.Fprintf(buf, "    if err := ValidationRegistry.Validate(ctx, %q, validation.OpUpdate, %sValidationRecord(input), input); err != nil {\n        return nil, err\n    }\n", ent.Name, strings.ToLower(ent.Name))

	updateCols := updatableColumns(ent)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sUpdateQuery", strings.ToLower(ent.Name))
	for _, col := range updateCols {
		field := findFieldByColumn(ent, col)
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ", input.%s)\n", exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    if c.cache != nil {\n        _ = c.cache.Set(ctx, makeCacheKey(%q, out.%s), out)\n    }\n", ent.Name, exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitBulkUpdateMethod(buf *bytes.Buffer, ent Entity, updateCols []string) {
	if len(updateCols) == 0 {
		return
	}
	updateFields := make([]dsl.Field, len(updateCols))
	for i, col := range updateCols {
		updateFields[i] = findFieldByColumn(ent, col)
	}
	fmt.Fprintf(buf, "func (c *%sClient) BulkUpdate(ctx context.Context, inputs []*%s) ([]*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if len(inputs) == 0 {\n        return []*%s{}, nil\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    specs := make([]runtime.BulkUpdateRow, 0, len(inputs))\n")
	needsNow := false
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	primaryFieldName := exportName(primaryField(ent).Name)
	fmt.Fprintf(buf, "    for _, input := range inputs {\n")
	fmt.Fprintf(buf, "        if input == nil {\n            return nil, errors.New(\"input cannot be nil\")\n        }\n")
	fmt.Fprintf(buf, "        if input.%s == \"\" {\n            return nil, errors.New(\"id is required\")\n        }\n", primaryFieldName)
	if needsNow {
		fmt.Fprintf(buf, "        now := time.Now().UTC()\n")
	}
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "        input.%s = now\n", exportName(field.Name))
		}
	}
	fmt.Fprintf(buf, "        if err := ValidationRegistry.Validate(ctx, %q, validation.OpUpdate, %sValidationRecord(input), input); err != nil {\n            return nil, err\n        }\n", ent.Name, strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "        row := runtime.BulkUpdateRow{\n")
	fmt.Fprintf(buf, "            Primary: input.%s,\n", primaryFieldName)
	fmt.Fprintf(buf, "            Values: []any{")
	for i, field := range updateFields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "},\n")
	fmt.Fprintf(buf, "        }\n")
	fmt.Fprintf(buf, "        specs = append(specs, row)\n")
	fmt.Fprintf(buf, "    }\n")
	columns := entityColumns(ent)
	fmt.Fprintf(buf, "    spec := runtime.BulkUpdateSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        PrimaryColumn: %q,\n", primaryColumn(ent))
	fmt.Fprintf(buf, "        Columns: %s,\n", quoteStringSlice(updateCols))
	fmt.Fprintf(buf, "        Returning: %s,\n", quoteStringSlice(columns))
	fmt.Fprintf(buf, "        Rows: specs,\n")
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    sql, args, err := runtime.BuildBulkUpdateSQL(spec)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var updated []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n")
	fmt.Fprintf(buf, "        item := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "        if err := rows.Scan(%s); err != nil {\n            return nil, err\n        }\n", scanArgs(ent))
	fmt.Fprintf(buf, "        updated = append(updated, item)\n")
	fmt.Fprintf(buf, "        if c.cache != nil {\n            _ = c.cache.Set(ctx, makeCacheKey(%q, item.%s), item)\n        }\n", ent.Name, primaryFieldName)
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return updated, nil\n}\n\n")
}

func emitDeleteMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Delete(ctx context.Context, id string) error {\n", ent.Name)
	fmt.Fprintf(buf, "    if _, err := c.db.Pool.Exec(ctx, %sDeleteQuery, id); err != nil {\n        return err\n    }\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    if c.cache != nil {\n        _ = c.cache.Delete(ctx, makeCacheKey(%q, id))\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitBulkDeleteMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {\n", ent.Name)
	fmt.Fprintf(buf, "    if len(ids) == 0 {\n        return 0, nil\n    }\n")
	fmt.Fprintf(buf, "    spec := runtime.BulkDeleteSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        PrimaryColumn: %q,\n", primaryColumn(ent))
	fmt.Fprintf(buf, "        IDs: make([]any, len(ids)),\n")
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    for i, id := range ids {\n        spec.IDs[i] = id\n    }\n")
	fmt.Fprintf(buf, "    sql, args, err := runtime.BuildBulkDeleteSQL(spec)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return 0, err\n    }\n")
	fmt.Fprintf(buf, "    tag, err := c.db.Pool.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return 0, err\n    }\n")
	fmt.Fprintf(buf, "    if c.cache != nil {\n        for _, id := range ids {\n            _ = c.cache.Delete(ctx, makeCacheKey(%q, id))\n        }\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    return int64(tag.RowsAffected()), nil\n}\n\n")
}

func emitValidationRecordHelper(buf *bytes.Buffer, ent Entity) {
	fn := strings.ToLower(ent.Name) + "ValidationRecord"
	fmt.Fprintf(buf, "func %s(input *%s) validation.Record {\n", fn, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    return validation.Record{\n")
	for _, field := range ent.Fields {
		if isReadOnlyField(field) {
			continue
		}
		fmt.Fprintf(buf, "        %q: input.%s,\n", exportName(field.Name), exportName(field.Name))
	}
	fmt.Fprintf(buf, "    }\n}\n\n")
}

func emitQueryBuilder(buf *bytes.Buffer, ent Entity) {
	spec := ent.Query
	columns := entityColumns(ent)

	fmt.Fprintf(buf, "type %sQuery struct {\n", ent.Name)
	fmt.Fprintf(buf, "    db *pg.DB\n")
	fmt.Fprintf(buf, "    predicates []runtime.Predicate\n")
	fmt.Fprintf(buf, "    orders []runtime.Order\n")
	fmt.Fprintf(buf, "    limit *int\n")
	fmt.Fprintf(buf, "    offset int\n")
	fmt.Fprintf(buf, "    defaultLimit int\n")
	fmt.Fprintf(buf, "    maxLimit int\n")
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (c *%sClient) Query() *%sQuery {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    return &%sQuery{db: c.db, defaultLimit: %d, maxLimit: %d}\n}\n\n", ent.Name, spec.DefaultLimit, spec.MaxLimit)

	fmt.Fprintf(buf, "func (q *%sQuery) Limit(n int) *%sQuery {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if n <= 0 {\n        q.limit = nil\n        return q\n    }\n")
	fmt.Fprintf(buf, "    q.limit = &n\n    return q\n}\n\n")

	fmt.Fprintf(buf, "func (q *%sQuery) Offset(n int) *%sQuery {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if n < 0 {\n        return q\n    }\n")
	fmt.Fprintf(buf, "    q.offset = n\n    return q\n}\n\n")

	fieldIndex := map[string]dsl.Field{}
	for _, field := range ent.Fields {
		fieldIndex[strings.ToLower(field.Name)] = field
	}

	for _, pred := range spec.Predicates {
		methodName := "Where" + predicateMethodName(pred)
		goType := predicateGoType(pred, fieldIndex)
		column := predicateColumn(pred, fieldIndex)
		fmt.Fprintf(buf, "func (q *%sQuery) %s(value %s) *%sQuery {\n", ent.Name, methodName, goType, ent.Name)
		fmt.Fprintf(buf, "    q.predicates = append(q.predicates, runtime.Predicate{Column: %q, Operator: %s, Value: value})\n", column, runtimeOperatorLiteral(pred.Operator))
		fmt.Fprintf(buf, "    return q\n}\n\n")
	}

	for _, order := range spec.Orders {
		methodName := "OrderBy" + orderMethodName(order)
		column := orderColumn(order, fieldIndex)
		fmt.Fprintf(buf, "func (q *%sQuery) %s() *%sQuery {\n", ent.Name, methodName, ent.Name)
		fmt.Fprintf(buf, "    q.orders = append(q.orders, runtime.Order{Column: %q, Direction: %s})\n", column, runtimeSortLiteral(order.Direction))
		fmt.Fprintf(buf, "    return q\n}\n\n")
	}

	emitQueryAll(buf, ent, columns)
	emitQueryStream(buf, ent, columns)
	emitQueryFirst(buf, ent)

	for _, agg := range spec.Aggregates {
		emitAggregateMethod(buf, ent, agg, fieldIndex)
	}

	fmt.Fprintf(buf, "func (q *%sQuery) clone() *%sQuery {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    cp := *q\n")
	fmt.Fprintf(buf, "    if len(q.predicates) > 0 {\n        cp.predicates = append([]runtime.Predicate(nil), q.predicates...)\n    }\n")
	fmt.Fprintf(buf, "    if len(q.orders) > 0 {\n        cp.orders = append([]runtime.Order(nil), q.orders...)\n    }\n")
	fmt.Fprintf(buf, "    if q.limit != nil {\n        limit := *q.limit\n        cp.limit = &limit\n    }\n")
	fmt.Fprintf(buf, "    return &cp\n}\n\n")

	fmt.Fprintf(buf, "func (q *%sQuery) effectiveLimit() int {\n", ent.Name)
	fmt.Fprintf(buf, "    if q.limit != nil {\n        limit := *q.limit\n        if q.maxLimit > 0 && limit > q.maxLimit {\n            return q.maxLimit\n        }\n        return limit\n    }\n")
	fmt.Fprintf(buf, "    limit := q.defaultLimit\n")
	fmt.Fprintf(buf, "    if limit <= 0 && q.maxLimit > 0 {\n        return q.maxLimit\n    }\n")
	fmt.Fprintf(buf, "    if q.maxLimit > 0 && limit > q.maxLimit {\n        return q.maxLimit\n    }\n")
	fmt.Fprintf(buf, "    return limit\n}\n")
}

func emitQueryAll(buf *bytes.Buffer, ent Entity, columns []string) {
	fmt.Fprintf(buf, "func (q *%sQuery) All(ctx context.Context) ([]*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    spec := runtime.SelectSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        Columns: %s,\n", quoteStringSlice(columns))
	fmt.Fprintf(buf, "        Predicates: q.predicates,\n")
	fmt.Fprintf(buf, "        Orders: q.orders,\n")
	fmt.Fprintf(buf, "        Limit: q.effectiveLimit(),\n")
	fmt.Fprintf(buf, "        Offset: q.offset,\n")
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    rows, err := q.db.Select(ctx, spec)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var result []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n")
	fmt.Fprintf(buf, "        item := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "        if err := rows.Scan(%s); err != nil {\n            return nil, err\n        }\n", scanArgs(ent))
	fmt.Fprintf(buf, "        result = append(result, item)\n    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return result, nil\n}\n\n")
}

func emitQueryStream(buf *bytes.Buffer, ent Entity, columns []string) {
	fmt.Fprintf(buf, "func (q *%sQuery) Stream(ctx context.Context) (*runtime.Stream[*%s], error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    spec := runtime.SelectSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        Columns: %s,\n", quoteStringSlice(columns))
	fmt.Fprintf(buf, "        Predicates: q.predicates,\n")
	fmt.Fprintf(buf, "        Orders: q.orders,\n")
	fmt.Fprintf(buf, "        Limit: q.effectiveLimit(),\n")
	fmt.Fprintf(buf, "        Offset: q.offset,\n")
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    rows, err := q.db.Select(ctx, spec)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    stream := runtime.NewStream[*%s](rows, func(rows pgx.Rows) (*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "        item := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "        if err := rows.Scan(%s); err != nil {\n            return nil, err\n        }\n", scanArgs(ent))
	fmt.Fprintf(buf, "        return item, nil\n    })\n")
	fmt.Fprintf(buf, "    return stream, nil\n}\n\n")
}

func emitQueryFirst(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (q *%sQuery) First(ctx context.Context) (*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    clone := q.clone()\n")
	fmt.Fprintf(buf, "    one := 1\n")
	fmt.Fprintf(buf, "    clone.limit = &one\n")
	fmt.Fprintf(buf, "    items, err := clone.All(ctx)\n")
	fmt.Fprintf(buf, "    if err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    if len(items) == 0 {\n        return nil, nil\n    }\n")
	fmt.Fprintf(buf, "    return items[0], nil\n}\n\n")
}

func emitAggregateMethod(buf *bytes.Buffer, ent Entity, agg dsl.Aggregate, fields map[string]dsl.Field) {
	methodName := exportName(agg.Name)
	if methodName == "" {
		methodName = "Aggregate"
	}
	goType := aggregateGoType(agg, fields)
	column := aggregateColumn(agg, fields)
	fmt.Fprintf(buf, "func (q *%sQuery) %s(ctx context.Context) (%s, error) {\n", ent.Name, methodName, goType)
	fmt.Fprintf(buf, "    spec := runtime.AggregateSpec{\n")
	fmt.Fprintf(buf, "        Table: %q,\n", pluralize(ent.Name))
	fmt.Fprintf(buf, "        Predicates: q.predicates,\n")
	fmt.Fprintf(buf, "        Aggregate: runtime.Aggregate{Func: %s, Column: %q},\n", runtimeAggregateLiteral(agg.Func), column)
	fmt.Fprintf(buf, "    }\n")
	fmt.Fprintf(buf, "    row := q.db.Aggregate(ctx, spec)\n")
	fmt.Fprintf(buf, "    var out %s\n", goType)
	fmt.Fprintf(buf, "    if err := row.Scan(&out); err != nil {\n        return out, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitEdgeLoaders(buf *bytes.Buffer, ent Entity, entityIndex map[string]Entity) {
	if len(ent.Edges) == 0 {
		return
	}
	for _, edge := range ent.Edges {
		switch edge.Kind {
		case dsl.EdgeToOne:
			emitToOneLoader(buf, ent, edge, entityIndex)
		case dsl.EdgeToMany:
			emitToManyLoader(buf, ent, edge, entityIndex)
		case dsl.EdgeManyToMany:
			emitManyToManyLoader(buf, ent, edge, entityIndex)
		}
	}
}

func emitToOneLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	targetPrimary := primaryField(target)
	fkField, found := fieldByColumn(source, edgeColumn(edge))
	if !found {
		return
	}
	keyType := goTypeForField(fkField)
	targetKeyField := exportName(targetPrimary.Name)
	fkFieldName := exportName(fkField.Name)
	columns := entityColumns(target)
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s IN (%%s)", strings.Join(columns, ", "), pluralize(edge.Target), fieldColumn(targetPrimary))
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        edges.markLoaded(%q)\n        fk := parent.%s\n        if isZero(fk) {\n            edges.%s = nil\n            continue\n        }\n        if _, ok := seen[fk]; !ok {\n            seen[fk] = struct{}{}\n            keys = append(keys, fk)\n        }\n    }\n", source.Name, edge.Name, fkFieldName, exportName(edge.Name))
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    related := make(map[keyType]*%s, len(keys))\n", edge.Target)
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        key := item.%s\n        related[key] = item\n    }\n", edge.Target, scanArgs(target), targetKeyField)
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        fk := parent.%s\n        edges := ensure%sEdges(parent)\n        if isZero(fk) {\n            edges.%s = nil\n            continue\n        }\n        if item, ok := related[fk]; ok {\n            edges.%s = item\n        } else {\n            edges.%s = nil\n        }\n    }\n", fkFieldName, source.Name, exportName(edge.Name), exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitToManyLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	sourcePrimary := primaryField(source)
	targetRefColumn := edgeRefColumn(source, edge, sourcePrimary)
	if targetRefColumn == "" {
		return
	}
	refField, found := fieldByColumn(target, targetRefColumn)
	if !found {
		return
	}
	keyType := goTypeForField(sourcePrimary)
	sourceKeyName := exportName(sourcePrimary.Name)
	refFieldName := exportName(refField.Name)
	columns := entityColumns(target)
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s IN (%%s)", strings.Join(columns, ", "), pluralize(edge.Target), targetRefColumn)
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    buckets := make(map[keyType][]*%s, len(parents))\n", source.Name)
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        key := parent.%s\n        if isZero(key) {\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n            continue\n        }\n        if _, ok := seen[key]; !ok {\n            seen[key] = struct{}{}\n            keys = append(keys, key)\n        }\n        buckets[key] = append(buckets[key], parent)\n    }\n", sourceKeyName, source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        for _, parent := range parents {\n            if parent == nil {\n                continue\n            }\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n        }\n        return nil\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        owner := item.%s\n        parents, ok := buckets[owner]\n        if !ok {\n            continue\n        }\n        for _, parent := range parents {\n            edges := ensure%sEdges(parent)\n            edges.%s = append(edges.%s, item)\n        }\n    }\n", edge.Target, scanArgs(target), refFieldName, source.Name, exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        if edges.%s == nil {\n            edges.%s = []*%s{}\n        }\n        edges.markLoaded(%q)\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitManyToManyLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	sourcePrimary := primaryField(source)
	targetPrimary := primaryField(target)
	joinTable, leftColumn, rightColumn := manyToManyJoinSpec(source, sourcePrimary, edge, targetPrimary)
	if joinTable == "" {
		return
	}
	keyType := goTypeForField(sourcePrimary)
	sourceKeyName := exportName(sourcePrimary.Name)
	columns := entityColumns(target)
	selectCols := append([]string{}, columns...)
	selectCols = append(selectCols, fmt.Sprintf("jt.%s", leftColumn))
	query := fmt.Sprintf("SELECT %s FROM %s AS t JOIN %s AS jt ON t.%s = jt.%s WHERE jt.%s IN (%%s)", strings.Join(selectCols, ", "), pluralize(edge.Target), joinTable, fieldColumn(targetPrimary), rightColumn, leftColumn)
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    buckets := make(map[keyType][]*%s, len(parents))\n", source.Name)
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        key := parent.%s\n        if isZero(key) {\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n            continue\n        }\n        if _, ok := seen[key]; !ok {\n            seen[key] = struct{}{}\n            keys = append(keys, key)\n        }\n        buckets[key] = append(buckets[key], parent)\n    }\n", sourceKeyName, source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        for _, parent := range parents {\n            if parent == nil {\n                continue\n            }\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n        }\n        return nil\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        var owner keyType\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        parents, ok := buckets[owner]\n        if !ok {\n            continue\n        }\n        for _, parent := range parents {\n            edges := ensure%sEdges(parent)\n            edges.%s = append(edges.%s, item)\n        }\n    }\n", edge.Target, scanArgsWithExtra(target, "&owner"), source.Name, exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        if edges.%s == nil {\n            edges.%s = []*%s{}\n        }\n        edges.markLoaded(%q)\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitRelationshipHelpers(buf *bytes.Buffer) {
	fmt.Fprintf(buf, "func buildInQuery[T any](base string, values []T) (string, []any) {\n")
	fmt.Fprintf(buf, "    if len(values) == 0 {\n        return base, nil\n    }\n")
	fmt.Fprintf(buf, "    placeholders := make([]string, len(values))\n")
	fmt.Fprintf(buf, "    args := make([]any, len(values))\n")
	fmt.Fprintf(buf, "    for i := range values {\n        placeholders[i] = fmt.Sprintf(\"$%%d\", i+1)\n        args[i] = values[i]\n    }\n")
	fmt.Fprintf(buf, "    return fmt.Sprintf(base, strings.Join(placeholders, %q)), args\n}\n\n", ", ")

	fmt.Fprintf(buf, "func isZero[T comparable](v T) bool {\n    var zero T\n    return v == zero\n}\n\n")
}

func scanArgs(ent Entity) string { return strings.Join(scanArgsForVar(ent, "item"), ", ") }

func scanArgsWithExtra(ent Entity, extra string) string {
	parts := scanArgsForVar(ent, "item")
	if extra != "" {
		parts = append(parts, extra)
	}
	return strings.Join(parts, ", ")
}

func scanArgsForVar(ent Entity, varName string) []string {
	parts := make([]string, len(ent.Fields))
	for i, field := range ent.Fields {
		parts[i] = fmt.Sprintf("&%s.%s", varName, exportName(field.Name))
	}
	return parts
}

func predicateMethodName(pred dsl.Predicate) string {
	if pred.Name != "" {
		return exportName(pred.Name)
	}
	return exportName(pred.Field) + operatorSuffix(pred.Operator)
}

func predicateGoType(pred dsl.Predicate, fields map[string]dsl.Field) string {
	if field, ok := fields[strings.ToLower(pred.Field)]; ok {
		return baseGoType(field)
	}
	return "any"
}

func predicateColumn(pred dsl.Predicate, fields map[string]dsl.Field) string {
	if field, ok := fields[strings.ToLower(pred.Field)]; ok {
		return fieldColumn(field)
	}
	return pred.Field
}

func orderMethodName(order dsl.Order) string {
	if order.Name != "" {
		return exportName(order.Name)
	}
	suffix := "Asc"
	if order.Direction == dsl.SortDesc {
		suffix = "Desc"
	}
	return exportName(order.Field) + suffix
}

func orderColumn(order dsl.Order, fields map[string]dsl.Field) string {
	if field, ok := fields[strings.ToLower(order.Field)]; ok {
		return fieldColumn(field)
	}
	return order.Field
}

func aggregateColumn(agg dsl.Aggregate, fields map[string]dsl.Field) string {
	switch agg.Field {
	case "", "*":
		return "*"
	default:
		if field, ok := fields[strings.ToLower(agg.Field)]; ok {
			return fieldColumn(field)
		}
		return agg.Field
	}
}

func aggregateGoType(agg dsl.Aggregate, fields map[string]dsl.Field) string {
	if agg.GoType != "" {
		return agg.GoType
	}
	switch agg.Field {
	case "", "*":
	default:
		if field, ok := fields[strings.ToLower(agg.Field)]; ok {
			return goTypeForField(field)
		}
	}
	switch agg.Func {
	case dsl.AggCount:
		return "int"
	case dsl.AggAvg, dsl.AggSum:
		return "float64"
	case dsl.AggMin, dsl.AggMax:
		return "any"
	default:
		return "any"
	}
}

func edgeTargetsLiteral(targets []dsl.EdgeTarget) string {
	if len(targets) == 0 {
		return "nil"
	}
	items := make([]string, len(targets))
	for i, target := range targets {
		items[i] = fmt.Sprintf("{Entity: %q, Condition: %q}", target.Entity, target.Condition)
	}
	return fmt.Sprintf("[]runtime.EdgeTargetSpec{%s}", strings.Join(items, ", "))
}

func edgeCascadeLiteral(c dsl.EdgeCascade) string {
	return fmt.Sprintf("runtime.CascadeSpec{OnDelete: %s, OnUpdate: %s}", cascadeActionLiteral(c.OnDelete), cascadeActionLiteral(c.OnUpdate))
}

func cascadeActionLiteral(action dsl.CascadeAction) string {
	switch action {
	case dsl.CascadeNoAction:
		return "runtime.CascadeNoAction"
	case dsl.CascadeRestrict:
		return "runtime.CascadeRestrict"
	case dsl.CascadeCascade:
		return "runtime.CascadeCascade"
	case dsl.CascadeSetNull:
		return "runtime.CascadeSetNull"
	case dsl.CascadeSetDefault:
		return "runtime.CascadeSetDefault"
	default:
		return "runtime.CascadeUnset"
	}
}

func operatorSuffix(op dsl.ComparisonOperator) string {
	switch op {
	case dsl.OpEqual:
		return "Eq"
	case dsl.OpNotEqual:
		return "NotEq"
	case dsl.OpGreaterThan:
		return "GT"
	case dsl.OpLessThan:
		return "LT"
	case dsl.OpGTE:
		return "GTE"
	case dsl.OpLTE:
		return "LTE"
	case dsl.OpILike:
		return "ILike"
	default:
		return "Eq"
	}
}

func runtimeOperatorLiteral(op dsl.ComparisonOperator) string {
	switch op {
	case dsl.OpEqual:
		return "runtime.OpEqual"
	case dsl.OpNotEqual:
		return "runtime.OpNotEqual"
	case dsl.OpGreaterThan:
		return "runtime.OpGreaterThan"
	case dsl.OpLessThan:
		return "runtime.OpLessThan"
	case dsl.OpGTE:
		return "runtime.OpGTE"
	case dsl.OpLTE:
		return "runtime.OpLTE"
	case dsl.OpILike:
		return "runtime.OpILike"
	default:
		return "runtime.OpEqual"
	}
}

func runtimeSortLiteral(dir dsl.SortDirection) string {
	switch dir {
	case dsl.SortDesc:
		return "runtime.SortDesc"
	default:
		return "runtime.SortAsc"
	}
}

func runtimeAggregateLiteral(fn dsl.AggregateFunc) string {
	switch fn {
	case dsl.AggSum:
		return "runtime.AggSum"
	case dsl.AggAvg:
		return "runtime.AggAvg"
	case dsl.AggMin:
		return "runtime.AggMin"
	case dsl.AggMax:
		return "runtime.AggMax"
	default:
		return "runtime.AggCount"
	}
}

func fieldByColumn(ent Entity, column string) (dsl.Field, bool) {
	for _, field := range ent.Fields {
		if fieldColumn(field) == column {
			return field, true
		}
	}
	return dsl.Field{}, false
}

func goTypeForField(field dsl.Field) string {
	return baseGoType(field)
}

func edgeRefColumn(source Entity, edge dsl.Edge, primary dsl.Field) string {
	if edge.RefName != "" {
		return edge.RefName
	}
	if primary.Name == "" {
		return ""
	}
	return fmt.Sprintf("%s_%s", toSnakeCase(source.Name), fieldColumn(primary))
}

func manyToManyJoinSpec(source Entity, sourcePrimary dsl.Field, edge dsl.Edge, targetPrimary dsl.Field) (string, string, string) {
	joinTable := edge.Through
	if joinTable == "" {
		joinTable = defaultJoinTableName(source.Name, edge.Target)
	}
	if joinTable == "" {
		return "", "", ""
	}
	left := fmt.Sprintf("%s_%s", toSnakeCase(source.Name), fieldColumn(sourcePrimary))
	right := fmt.Sprintf("%s_%s", toSnakeCase(edge.Target), fieldColumn(targetPrimary))
	return joinTable, left, right
}

func emitEdgesStruct(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "type %sEdges struct {\n", ent.Name)
	fmt.Fprintf(buf, "    loaded map[string]bool\n")
	for _, edge := range ent.Edges {
		fieldName := exportName(edge.Name)
		jsonTag := jsonName(edge.Name)
		switch edge.Kind {
		case dsl.EdgeToOne:
			fmt.Fprintf(buf, "    %s *%s `json:\"%s,omitempty\"`\n", fieldName, edge.Target, jsonTag)
		case dsl.EdgeToMany, dsl.EdgeManyToMany:
			fmt.Fprintf(buf, "    %s []*%s `json:\"%s,omitempty\"`\n", fieldName, edge.Target, jsonTag)
		}
	}
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (e *%sEdges) markLoaded(name string) {\n", ent.Name)
	fmt.Fprintf(buf, "    if e == nil {\n        return\n    }\n")
	fmt.Fprintf(buf, "    if e.loaded == nil {\n        e.loaded = make(map[string]bool)\n    }\n")
	fmt.Fprintf(buf, "    e.loaded[name] = true\n}\n\n")
}

func emitEdgeAccessors(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func ensure%sEdges(m *%s) *%sEdges {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if m.Edges == nil {\n        m.Edges = &%sEdges{}\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    if m.Edges.loaded == nil {\n        m.Edges.loaded = make(map[string]bool)\n    }\n")
	fmt.Fprintf(buf, "    return m.Edges\n}\n\n")

	fmt.Fprintf(buf, "func (m *%s) EdgeLoaded(name string) bool {\n", ent.Name)
	fmt.Fprintf(buf, "    if m == nil || m.Edges == nil || m.Edges.loaded == nil {\n        return false\n    }\n")
	fmt.Fprintf(buf, "    return m.Edges.loaded[name]\n}\n\n")

	for _, edge := range ent.Edges {
		fieldName := exportName(edge.Name)
		jsonTag := edge.Name
		switch edge.Kind {
		case dsl.EdgeToOne:
			fmt.Fprintf(buf, "func (m *%s) Set%s(value *%s) {\n", ent.Name, fieldName, edge.Target)
			fmt.Fprintf(buf, "    edges := ensure%sEdges(m)\n", ent.Name)
			fmt.Fprintf(buf, "    edges.%s = value\n", fieldName)
			fmt.Fprintf(buf, "    edges.markLoaded(%q)\n}\n\n", jsonTag)
		case dsl.EdgeToMany, dsl.EdgeManyToMany:
			fmt.Fprintf(buf, "func (m *%s) Set%s(values []*%s) {\n", ent.Name, fieldName, edge.Target)
			fmt.Fprintf(buf, "    edges := ensure%sEdges(m)\n", ent.Name)
			fmt.Fprintf(buf, "    if values == nil {\n        values = []*%s{}\n    }\n", edge.Target)
			fmt.Fprintf(buf, "    edges.%s = values\n", fieldName)
			fmt.Fprintf(buf, "    edges.markLoaded(%q)\n}\n\n", jsonTag)
		}
	}
}

func entityColumns(ent Entity) []string {
	cols := make([]string, len(ent.Fields))
	for i, field := range ent.Fields {
		cols[i] = fieldColumn(field)
	}
	return cols
}

func insertColumns(ent Entity) []string {
	fields := insertableFields(ent)
	cols := make([]string, len(fields))
	for i, field := range fields {
		cols[i] = fieldColumn(field)
	}
	return cols
}

func insertableFields(ent Entity) []dsl.Field {
	fields := make([]dsl.Field, 0, len(ent.Fields))
	for _, field := range ent.Fields {
		if isReadOnlyField(field) {
			continue
		}
		fields = append(fields, field)
	}
	return fields
}

func computedFields(ent Entity) []dsl.Field {
	fields := []dsl.Field{}
	for _, field := range ent.Fields {
		if isComputedField(field) {
			fields = append(fields, field)
		}
	}
	return fields
}

func isComputedField(field dsl.Field) bool {
	return field.ComputedSpec != nil
}

func isReadOnlyField(field dsl.Field) bool {
	if field.ComputedSpec != nil {
		return true
	}
	return field.ReadOnly
}

func placeholders(n int) string {
	items := make([]string, n)
	for i := 0; i < n; i++ {
		items[i] = fmt.Sprintf("$%d", i+1)
	}
	return strings.Join(items, ", ")
}

func primaryColumn(ent Entity) string {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return fieldColumn(field)
		}
	}
	return fieldColumn(ent.Fields[0])
}

func primaryField(ent Entity) dsl.Field {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return field
		}
	}
	return ent.Fields[0]
}

func updatableColumns(ent Entity) []string {
	cols := []string{}
	for _, field := range ent.Fields {
		if field.IsPrimary {
			continue
		}
		if isReadOnlyField(field) {
			continue
		}
		if field.HasDefaultNow && !field.HasUpdateNow {
			continue
		}
		cols = append(cols, fieldColumn(field))
	}
	return cols
}

func findFieldByColumn(ent Entity, column string) dsl.Field {
	for _, field := range ent.Fields {
		if fieldColumn(field) == column {
			return field
		}
	}
	return ent.Fields[0]
}

func fieldTypeLiteral(ft dsl.FieldType) string {
	switch ft {
	case dsl.TypeUUID:
		return "dsl.TypeUUID"
	case dsl.TypeEnum:
		return "dsl.TypeEnum"
	case dsl.TypeText:
		return "dsl.TypeText"
	case dsl.TypeVarChar:
		return "dsl.TypeVarChar"
	case dsl.TypeChar:
		return "dsl.TypeChar"
	case dsl.TypeBoolean:
		return "dsl.TypeBoolean"
	case dsl.TypeSmallInt:
		return "dsl.TypeSmallInt"
	case dsl.TypeInteger:
		return "dsl.TypeInteger"
	case dsl.TypeBigInt:
		return "dsl.TypeBigInt"
	case dsl.TypeSmallSerial:
		return "dsl.TypeSmallSerial"
	case dsl.TypeSerial:
		return "dsl.TypeSerial"
	case dsl.TypeBigSerial:
		return "dsl.TypeBigSerial"
	case dsl.TypeDecimal:
		return "dsl.TypeDecimal"
	case dsl.TypeNumeric:
		return "dsl.TypeNumeric"
	case dsl.TypeReal:
		return "dsl.TypeReal"
	case dsl.TypeDoublePrecision:
		return "dsl.TypeDoublePrecision"
	case dsl.TypeMoney:
		return "dsl.TypeMoney"
	case dsl.TypeBytea:
		return "dsl.TypeBytea"
	case dsl.TypeDate:
		return "dsl.TypeDate"
	case dsl.TypeTime:
		return "dsl.TypeTime"
	case dsl.TypeTimeTZ:
		return "dsl.TypeTimeTZ"
	case dsl.TypeTimestamp:
		return "dsl.TypeTimestamp"
	case dsl.TypeTimestampTZ:
		return "dsl.TypeTimestampTZ"
	case dsl.TypeInterval:
		return "dsl.TypeInterval"
	case dsl.TypeJSON:
		return "dsl.TypeJSON"
	case dsl.TypeJSONB:
		return "dsl.TypeJSONB"
	case dsl.TypeXML:
		return "dsl.TypeXML"
	case dsl.TypeInet:
		return "dsl.TypeInet"
	case dsl.TypeCIDR:
		return "dsl.TypeCIDR"
	case dsl.TypeMACAddr:
		return "dsl.TypeMACAddr"
	case dsl.TypeMACAddr8:
		return "dsl.TypeMACAddr8"
	case dsl.TypeBit:
		return "dsl.TypeBit"
	case dsl.TypeVarBit:
		return "dsl.TypeVarBit"
	case dsl.TypeTSVector:
		return "dsl.TypeTSVector"
	case dsl.TypeTSQuery:
		return "dsl.TypeTSQuery"
	case dsl.TypePoint:
		return "dsl.TypePoint"
	case dsl.TypeLine:
		return "dsl.TypeLine"
	case dsl.TypeLseg:
		return "dsl.TypeLseg"
	case dsl.TypeBox:
		return "dsl.TypeBox"
	case dsl.TypePath:
		return "dsl.TypePath"
	case dsl.TypePolygon:
		return "dsl.TypePolygon"
	case dsl.TypeCircle:
		return "dsl.TypeCircle"
	case dsl.TypeInt4Range:
		return "dsl.TypeInt4Range"
	case dsl.TypeInt8Range:
		return "dsl.TypeInt8Range"
	case dsl.TypeNumRange:
		return "dsl.TypeNumRange"
	case dsl.TypeTSRange:
		return "dsl.TypeTSRange"
	case dsl.TypeTSTZRange:
		return "dsl.TypeTSTZRange"
	case dsl.TypeDateRange:
		return "dsl.TypeDateRange"
	case dsl.TypeArray:
		return "dsl.TypeArray"
	case dsl.TypeGeometry:
		return "dsl.TypeGeometry"
	case dsl.TypeGeography:
		return "dsl.TypeGeography"
	case dsl.TypeVector:
		return "dsl.TypeVector"
	default:
		return fmt.Sprintf("dsl.FieldType(%q)", string(ft))
	}
}

func edgeKindLiteral(kind dsl.EdgeKind) string {
	switch kind {
	case dsl.EdgeToOne:
		return "dsl.EdgeToOne"
	case dsl.EdgeToMany:
		return "dsl.EdgeToMany"
	case dsl.EdgeManyToMany:
		return "dsl.EdgeManyToMany"
	default:
		return fmt.Sprintf("dsl.EdgeKind(%q)", string(kind))
	}
}

func mapLiteral(input map[string]any) string {
	if len(input) == 0 {
		return "nil"
	}
	keys := make([]string, 0, len(input))
	for k := range input {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	parts := make([]string, 0, len(keys))
	for _, key := range keys {
		parts = append(parts, fmt.Sprintf("%q: %#v", key, input[key]))
	}
	return fmt.Sprintf("map[string]any{%s}", strings.Join(parts, ", "))
}

func computedLiteral(spec *dsl.ComputedColumn) string {
	if spec == nil {
		return "nil"
	}
	return fmt.Sprintf("&dsl.ComputedColumn{Expression: %s, Stored: %t, ReadOnly: %t}", expressionLiteral(spec.Expression), spec.Stored, spec.ReadOnly)
}

func expressionLiteral(expr dsl.ExpressionSpec) string {
	deps := quoteStringSlice(expr.Dependencies)
	if deps == "" {
		deps = "nil"
	}
	return fmt.Sprintf("dsl.ExpressionSpec{SQL: %q, Dependencies: %s}", expr.SQL, deps)
}
