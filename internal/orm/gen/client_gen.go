// Code generated by erm. DO NOT EDIT.
package gen

import (
	"context"
	"errors"
	"fmt"
	"github.com/deicod/erm/internal/orm/id"
	"github.com/deicod/erm/internal/orm/pg"
	"github.com/deicod/erm/internal/orm/runtime"
	"github.com/deicod/erm/internal/orm/runtime/cache"
	"github.com/deicod/erm/internal/orm/runtime/validation"
	"github.com/jackc/pgx/v5"
	"time"
)

var ValidationRegistry = validation.NewRegistry()

type Client struct {
	db    *pg.DB
	cache cache.Store
}

func NewClient(db *pg.DB) *Client {
	return &Client{db: db, cache: cache.Nop()}
}

func (c *Client) UseCache(store cache.Store) {
	if c == nil {
		return
	}
	if store == nil {
		store = cache.Nop()
	}
	c.cache = store
}

func (c *Client) cacheStore() cache.Store {
	if c == nil || c.cache == nil {
		return cache.Nop()
	}
	return c.cache
}

func makeCacheKey(entity string, id any) string {
	return "orm:" + entity + ":" + fmt.Sprint(id)
}

func (c *Client) Users() *UserClient {
	return &UserClient{db: c.db, cache: c.cacheStore()}
}

const userInsertQuery = `INSERT INTO users (id, created_at, updated_at) VALUES ($1, $2, $3) RETURNING id, slug, created_at, updated_at`
const userSelectQuery = `SELECT id, slug, created_at, updated_at FROM users WHERE id = $1`
const userListQuery = `SELECT id, slug, created_at, updated_at FROM users ORDER BY id LIMIT $1 OFFSET $2`
const userUpdateQuery = `UPDATE users SET updated_at = $1 WHERE id = $2 RETURNING id, slug, created_at, updated_at`
const userCountQuery = `SELECT COUNT(*) FROM users`
const userDeleteQuery = `DELETE FROM users WHERE id = $1`

type UserClient struct {
	db    *pg.DB
	cache cache.Store
}

func (c *UserClient) Create(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if !runtime.IsZeroValue(input.Slug) {
		return nil, fmt.Errorf("User.Slug is computed and cannot be set")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	writer := c.db.Writer()
	if writer == nil {
		return nil, errors.New("database writer pool is unavailable")
	}
	row := writer.QueryRow(ctx, userInsertQuery, input.ID, input.CreatedAt, input.UpdatedAt)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Slug, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkCreate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	rowsSpec := make([][]any, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if !runtime.IsZeroValue(input.Slug) {
			return nil, fmt.Errorf("User.Slug is computed and cannot be set")
		}
		now := time.Now().UTC()
		if input.ID == "" {
			v, err := id.NewV7()
			if err != nil {
				return nil, err
			}
			input.ID = v
		}
		if input.CreatedAt.IsZero() {
			input.CreatedAt = now
		}
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpCreate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := []any{input.ID, input.CreatedAt, input.UpdatedAt}
		rowsSpec = append(rowsSpec, row)
	}
	spec := runtime.BulkInsertSpec{
		Table:     "users",
		Columns:   []string{"id", "created_at", "updated_at"},
		Returning: []string{"id", "slug", "created_at", "updated_at"},
		Rows:      rowsSpec,
	}
	sql, args, err := runtime.BuildBulkInsertSQL(spec)
	if err != nil {
		return nil, err
	}
	writer := c.db.Writer()
	if writer == nil {
		return nil, errors.New("database writer pool is unavailable")
	}
	rows, err := writer.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var created []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Slug, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		created = append(created, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return created, nil
}

func (c *UserClient) ByID(ctx context.Context, id string) (*User, error) {
	var cachedKey string
	if c.cache != nil {
		cachedKey = makeCacheKey("User", id)
		if value, ok, err := c.cache.Get(ctx, cachedKey); err != nil {
			return nil, err
		} else if ok {
			if entity, ok := value.(*User); ok {
				return entity, nil
			}
		}
	}
	row := c.db.QueryRow(ctx, "users", userSelectQuery, id)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Slug, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	if c.cache != nil {
		cachedKey = makeCacheKey("User", out.ID)
		_ = c.cache.Set(ctx, cachedKey, out)
	}
	return out, nil
}

func (c *UserClient) List(ctx context.Context, limit, offset int) ([]*User, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Query(ctx, "users", userListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Slug, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *UserClient) Count(ctx context.Context) (int, error) {
	row := c.db.QueryRow(ctx, "users", userCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *UserClient) Update(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
		return nil, err
	}
	writer := c.db.Writer()
	if writer == nil {
		return nil, errors.New("database writer pool is unavailable")
	}
	row := writer.QueryRow(ctx, userUpdateQuery, input.UpdatedAt, input.ID)
	out := new(User)
	if err := row.Scan(&out.ID, &out.Slug, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	if c.cache != nil {
		_ = c.cache.Set(ctx, makeCacheKey("User", out.ID), out)
	}
	return out, nil
}

func (c *UserClient) BulkUpdate(ctx context.Context, inputs []*User) ([]*User, error) {
	if len(inputs) == 0 {
		return []*User{}, nil
	}
	specs := make([]runtime.BulkUpdateRow, 0, len(inputs))
	for _, input := range inputs {
		if input == nil {
			return nil, errors.New("input cannot be nil")
		}
		if input.ID == "" {
			return nil, errors.New("id is required")
		}
		now := time.Now().UTC()
		input.UpdatedAt = now
		if err := ValidationRegistry.Validate(ctx, "User", validation.OpUpdate, userValidationRecord(input), input); err != nil {
			return nil, err
		}
		row := runtime.BulkUpdateRow{
			Primary: input.ID,
			Values:  []any{input.UpdatedAt},
		}
		specs = append(specs, row)
	}
	spec := runtime.BulkUpdateSpec{
		Table:         "users",
		PrimaryColumn: "id",
		Columns:       []string{"updated_at"},
		Returning:     []string{"id", "slug", "created_at", "updated_at"},
		Rows:          specs,
	}
	sql, args, err := runtime.BuildBulkUpdateSQL(spec)
	if err != nil {
		return nil, err
	}
	rows, err := c.db.Query(ctx, "users", sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var updated []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Slug, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		updated = append(updated, item)
		if c.cache != nil {
			_ = c.cache.Set(ctx, makeCacheKey("User", item.ID), item)
		}
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return updated, nil
}

func (c *UserClient) Delete(ctx context.Context, id string) error {
	writer := c.db.Writer()
	if writer == nil {
		return errors.New("database writer pool is unavailable")
	}
	if _, err := writer.Exec(ctx, userDeleteQuery, id); err != nil {
		return err
	}
	if c.cache != nil {
		_ = c.cache.Delete(ctx, makeCacheKey("User", id))
	}
	return nil
}

func (c *UserClient) BulkDelete(ctx context.Context, ids []string) (int64, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	spec := runtime.BulkDeleteSpec{
		Table:         "users",
		PrimaryColumn: "id",
		IDs:           make([]any, len(ids)),
	}
	for i, id := range ids {
		spec.IDs[i] = id
	}
	sql, args, err := runtime.BuildBulkDeleteSQL(spec)
	if err != nil {
		return 0, err
	}
	writer := c.db.Writer()
	if writer == nil {
		return 0, errors.New("database writer pool is unavailable")
	}
	tag, err := writer.Exec(ctx, sql, args...)
	if err != nil {
		return 0, err
	}
	if c.cache != nil {
		for _, id := range ids {
			_ = c.cache.Delete(ctx, makeCacheKey("User", id))
		}
	}
	return int64(tag.RowsAffected()), nil
}

type UserQuery struct {
	db           *pg.DB
	predicates   []runtime.Predicate
	orders       []runtime.Order
	limit        *int
	offset       int
	defaultLimit int
	maxLimit     int
}

func (c *UserClient) Query() *UserQuery {
	return &UserQuery{db: c.db, defaultLimit: 20, maxLimit: 0}
}

func (q *UserQuery) Limit(n int) *UserQuery {
	if n <= 0 {
		q.limit = nil
		return q
	}
	q.limit = &n
	return q
}

func (q *UserQuery) Offset(n int) *UserQuery {
	if n < 0 {
		return q
	}
	q.offset = n
	return q
}

func (q *UserQuery) WhereIDEq(value string) *UserQuery {
	q.predicates = append(q.predicates, runtime.Predicate{Column: "id", Operator: runtime.OpEqual, Value: value})
	return q
}

func (q *UserQuery) OrderByCreatedAtAsc() *UserQuery {
	q.orders = append(q.orders, runtime.Order{Column: "created_at", Direction: runtime.SortAsc})
	return q
}

func (q *UserQuery) All(ctx context.Context) ([]*User, error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "slug", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Slug, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (q *UserQuery) Stream(ctx context.Context) (*runtime.Stream[*User], error) {
	spec := runtime.SelectSpec{
		Table:      "users",
		Columns:    []string{"id", "slug", "created_at", "updated_at"},
		Predicates: q.predicates,
		Orders:     q.orders,
		Limit:      q.effectiveLimit(),
		Offset:     q.offset,
	}
	rows, err := q.db.Select(ctx, spec)
	if err != nil {
		return nil, err
	}
	stream := runtime.NewStream[*User](rows, func(rows pgx.Rows) (*User, error) {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.Slug, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		return item, nil
	})
	return stream, nil
}

func (q *UserQuery) First(ctx context.Context) (*User, error) {
	clone := q.clone()
	one := 1
	clone.limit = &one
	items, err := clone.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(items) == 0 {
		return nil, nil
	}
	return items[0], nil
}

func (q *UserQuery) Count(ctx context.Context) (int, error) {
	spec := runtime.AggregateSpec{
		Table:      "users",
		Predicates: q.predicates,
		Aggregate:  runtime.Aggregate{Func: runtime.AggCount, Column: "*"},
	}
	row := q.db.Aggregate(ctx, spec)
	var out int
	if err := row.Scan(&out); err != nil {
		return out, err
	}
	return out, nil
}

func (q *UserQuery) clone() *UserQuery {
	cp := *q
	if len(q.predicates) > 0 {
		cp.predicates = append([]runtime.Predicate(nil), q.predicates...)
	}
	if len(q.orders) > 0 {
		cp.orders = append([]runtime.Order(nil), q.orders...)
	}
	if q.limit != nil {
		limit := *q.limit
		cp.limit = &limit
	}
	return &cp
}

func (q *UserQuery) effectiveLimit() int {
	if q.limit != nil {
		limit := *q.limit
		if q.maxLimit > 0 && limit > q.maxLimit {
			return q.maxLimit
		}
		return limit
	}
	limit := q.defaultLimit
	if limit <= 0 && q.maxLimit > 0 {
		return q.maxLimit
	}
	if q.maxLimit > 0 && limit > q.maxLimit {
		return q.maxLimit
	}
	return limit
}
func userValidationRecord(input *User) validation.Record {
	if input == nil {
		return nil
	}
	return validation.Record{
		"ID":        input.ID,
		"CreatedAt": input.CreatedAt,
		"UpdatedAt": input.UpdatedAt,
	}
}
