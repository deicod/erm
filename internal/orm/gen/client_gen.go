// Code generated by erm. DO NOT EDIT.
package gen

import (
	"context"
	"errors"
	"github.com/deicod/erm/internal/orm/id"
	"github.com/deicod/erm/internal/orm/pg"
	"github.com/jackc/pgx/v5"
	"time"
)

type Client struct {
	db *pg.DB
}

func NewClient(db *pg.DB) *Client {
	return &Client{db: db}
}

func (c *Client) Users() *UserClient {
	return &UserClient{db: c.db}
}

const userInsertQuery = `INSERT INTO users (id, created_at, updated_at) VALUES ($1, $2, $3) RETURNING id, created_at, updated_at`
const userSelectQuery = `SELECT id, created_at, updated_at FROM users WHERE id = $1`
const userListQuery = `SELECT id, created_at, updated_at FROM users ORDER BY id LIMIT $1 OFFSET $2`
const userUpdateQuery = `UPDATE users SET updated_at = $1 WHERE id = $2 RETURNING id, created_at, updated_at`
const userCountQuery = `SELECT COUNT(*) FROM users`
const userDeleteQuery = `DELETE FROM users WHERE id = $1`

type UserClient struct {
	db *pg.DB
}

func (c *UserClient) Create(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	now := time.Now().UTC()
	if input.ID == "" {
		v, err := id.NewV7()
		if err != nil {
			return nil, err
		}
		input.ID = v
	}
	if input.CreatedAt.IsZero() {
		input.CreatedAt = now
	}
	input.UpdatedAt = now
	row := c.db.Pool.QueryRow(ctx, userInsertQuery, input.ID, input.CreatedAt, input.UpdatedAt)
	out := new(User)
	if err := row.Scan(&out.ID, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	return out, nil
}

func (c *UserClient) ByID(ctx context.Context, id string) (*User, error) {
	row := c.db.Pool.QueryRow(ctx, userSelectQuery, id)
	out := new(User)
	if err := row.Scan(&out.ID, &out.CreatedAt, &out.UpdatedAt); err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return out, nil
}

func (c *UserClient) List(ctx context.Context, limit, offset int) ([]*User, error) {
	if limit <= 0 {
		limit = 20
	}
	if offset < 0 {
		offset = 0
	}
	rows, err := c.db.Pool.Query(ctx, userListQuery, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*User
	for rows.Next() {
		item := new(User)
		if err := rows.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *UserClient) Count(ctx context.Context) (int, error) {
	row := c.db.Pool.QueryRow(ctx, userCountQuery)
	var total int
	if err := row.Scan(&total); err != nil {
		return 0, err
	}
	return total, nil
}

func (c *UserClient) Update(ctx context.Context, input *User) (*User, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}
	if input.ID == "" {
		return nil, errors.New("id is required")
	}
	now := time.Now().UTC()
	input.UpdatedAt = now
	row := c.db.Pool.QueryRow(ctx, userUpdateQuery, input.UpdatedAt, input.ID)
	out := new(User)
	if err := row.Scan(&out.ID, &out.CreatedAt, &out.UpdatedAt); err != nil {
		return nil, err
	}
	return out, nil
}

func (c *UserClient) Delete(ctx context.Context, id string) error {
	_, err := c.db.Pool.Exec(ctx, userDeleteQuery, id)
	return err
}
