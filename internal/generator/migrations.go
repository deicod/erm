package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/deicod/erm/internal/orm/dsl"
	"gopkg.in/yaml.v3"
)

func ensureMigrationsPlaceholder(root string, entities []Entity) error {
	dir := filepath.Join(root, "migrations")
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(dir, "001_initial.sql")
	if _, err := os.ReadFile(path); err == nil {
		return nil
	}
	cfg := loadProjectConfig(root)
	usage := detectExtensionUsage(entities)
	flags := extensionFlags{
		postgis:   cfg.Extensions.PostGIS || usage.postgis,
		pgvector:  cfg.Extensions.PGVector || usage.pgvector,
		timescale: cfg.Extensions.Timescale || usage.timescale,
	}
	sql := renderInitialMigration(entities, flags)
	return writeFile(path, []byte(sql))
}

type entityMigration struct {
	Entity      Entity
	Fields      []dsl.Field
	ForeignKeys []foreignKeySpec
	fieldIndex  map[string]int
	fkIndex     map[string]struct{}
}

type foreignKeySpec struct {
	Column        string
	TargetTable   string
	TargetColumn  string
	ConstraintKey string
}

type joinTableSpec struct {
	Name  string
	Left  joinTableColumn
	Right joinTableColumn
}

type joinTableColumn struct {
	Column       string
	TargetTable  string
	TargetColumn string
	SQLType      string
}

func renderInitialMigration(entities []Entity, flags extensionFlags) string {
	buf := &bytes.Buffer{}
	buf.WriteString("-- Code generated by erm.\n")
	buf.WriteString("-- Initial schema migration.\n\n")
	if flags.postgis {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS postgis;\n")
	}
	if flags.pgvector {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS vector;\n")
	}
	if flags.timescale {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS timescaledb;\n")
	}
	if flags.postgis || flags.pgvector || flags.timescale {
		buf.WriteString("\n")
	}
	migrationEntities, joinTables := buildMigrationPlan(entities)
	sort.Slice(migrationEntities, func(i, j int) bool { return migrationEntities[i].Entity.Name < migrationEntities[j].Entity.Name })
	var deferredFKs []string
	for _, ent := range migrationEntities {
		table := pluralize(ent.Entity.Name)
		buf.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", table))
		cols := make([]string, 0, len(ent.Fields)+1)
		primaryCols := make([]string, 0, 1)
		var hypertableColumn string
		for _, field := range ent.Fields {
			column := fieldColumn(field)
			colDef := fmt.Sprintf("    %s %s", column, fieldSQLType(field))
			if !field.Nullable {
				colDef += " NOT NULL"
			}
			if field.IsPrimary {
				primaryCols = append(primaryCols, column)
			}
			if field.HasDefaultNow {
				colDef += " DEFAULT now()"
			} else if field.DefaultExpr != "" {
				colDef += fmt.Sprintf(" DEFAULT %s", field.DefaultExpr)
			}
			if field.IsUnique {
				colDef += " UNIQUE"
			}
			if ts, ok := field.Annotations["timeseries"].(bool); ok && ts {
				hypertableColumn = column
			}
			cols = append(cols, colDef)
		}
		if len(primaryCols) > 0 {
			cols = append(cols, fmt.Sprintf("    PRIMARY KEY (%s)", strings.Join(primaryCols, ", ")))
		}
		buf.WriteString(strings.Join(cols, ",\n"))
		buf.WriteString("\n);\n\n")

		for _, fk := range ent.ForeignKeys {
			deferredFKs = append(deferredFKs, fmt.Sprintf("ALTER TABLE %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s);", table, fk.ConstraintKey, fk.Column, fk.TargetTable, fk.TargetColumn))
		}

		// Indexes
		for _, idx := range ent.Entity.Indexes {
			method := ""
			if idx.Method != "" {
				method = fmt.Sprintf(" USING %s", idx.Method)
			}
			unique := ""
			if idx.IsUnique {
				unique = " UNIQUE"
			}
			where := ""
			if idx.Where != "" {
				where = fmt.Sprintf(" WHERE %s", idx.Where)
			}
			cols := strings.Join(idx.Columns, ", ")
			buf.WriteString(fmt.Sprintf("CREATE%s INDEX IF NOT EXISTS %s ON %s%s (%s)%s;\n\n", unique, idx.Name, table, method, cols, where))
		}

		if hypertableColumn != "" {
			buf.WriteString(fmt.Sprintf("SELECT create_hypertable('%s', '%s', if_not_exists => TRUE);\n\n", table, hypertableColumn))
		}
	}
	if len(deferredFKs) > 0 {
		for _, stmt := range deferredFKs {
			buf.WriteString(stmt)
			buf.WriteString("\n")
		}
		buf.WriteString("\n")
	}
	if len(joinTables) > 0 {
		sort.Slice(joinTables, func(i, j int) bool { return joinTables[i].Name < joinTables[j].Name })
		for _, jt := range joinTables {
			buf.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", jt.Name))
			cols := []string{
				fmt.Sprintf("    %s %s NOT NULL", jt.Left.Column, jt.Left.SQLType),
				fmt.Sprintf("    %s %s NOT NULL", jt.Right.Column, jt.Right.SQLType),
				fmt.Sprintf("    PRIMARY KEY (%s, %s)", jt.Left.Column, jt.Right.Column),
				fmt.Sprintf("    CONSTRAINT fk_%s_%s FOREIGN KEY (%s) REFERENCES %s (%s)", jt.Name, jt.Left.Column, jt.Left.Column, jt.Left.TargetTable, jt.Left.TargetColumn),
				fmt.Sprintf("    CONSTRAINT fk_%s_%s FOREIGN KEY (%s) REFERENCES %s (%s)", jt.Name, jt.Right.Column, jt.Right.Column, jt.Right.TargetTable, jt.Right.TargetColumn),
			}
			buf.WriteString(strings.Join(cols, ",\n"))
			buf.WriteString("\n);\n\n")
		}
	}
	return buf.String()
}

func buildMigrationPlan(entities []Entity) ([]entityMigration, []joinTableSpec) {
	plan := make([]entityMigration, len(entities))
	entityIndex := make(map[string]*entityMigration, len(entities))
	for i, ent := range entities {
		fields := make([]dsl.Field, len(ent.Fields))
		copy(fields, ent.Fields)
		fieldIndex := make(map[string]int, len(fields))
		for idx, field := range fields {
			fieldIndex[fieldColumn(field)] = idx
		}
		plan[i] = entityMigration{
			Entity:      ent,
			Fields:      fields,
			ForeignKeys: []foreignKeySpec{},
			fieldIndex:  fieldIndex,
			fkIndex:     map[string]struct{}{},
		}
		entityIndex[ent.Name] = &plan[i]
	}

	joinTableMap := map[string]joinTableSpec{}

	for i := range plan {
		src := &plan[i]
		srcPrimary, ok := findPrimaryField(src.Entity)
		if !ok {
			continue
		}
		for _, edge := range src.Entity.Edges {
			switch edge.Kind {
			case dsl.EdgeToOne:
				ensureToOneColumn(src, entityIndex, edge)
			case dsl.EdgeToMany:
				ensureToManyColumn(src, entityIndex, edge, srcPrimary)
			case dsl.EdgeManyToMany:
				ensureJoinTable(joinTableMap, src.Entity, entityIndex, edge, srcPrimary)
			}
		}
	}

	joinTables := make([]joinTableSpec, 0, len(joinTableMap))
	for _, jt := range joinTableMap {
		joinTables = append(joinTables, jt)
	}
	return plan, joinTables
}

func ensureToOneColumn(src *entityMigration, entityIndex map[string]*entityMigration, edge dsl.Edge) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	targetPrimary, ok := findPrimaryField(target.Entity)
	if !ok {
		return
	}
	column := edgeColumn(edge)
	if column == "" {
		return
	}
	fkField := makeForeignKeyField(column, targetPrimary, edge.Nullable, edge.Unique)
	if idx, exists := src.fieldIndex[column]; exists {
		existing := src.Fields[idx]
		if edge.Nullable && !existing.Nullable {
			existing.Nullable = true
		}
		if edge.Unique && !existing.IsUnique {
			existing.IsUnique = true
		}
		src.Fields[idx] = existing
	} else {
		src.Fields = append(src.Fields, fkField)
		src.fieldIndex[column] = len(src.Fields) - 1
	}
	constraint := fmt.Sprintf("fk_%s_%s", pluralize(src.Entity.Name), column)
	if _, exists := src.fkIndex[column]; !exists {
		src.ForeignKeys = append(src.ForeignKeys, foreignKeySpec{
			Column:        column,
			TargetTable:   pluralize(edge.Target),
			TargetColumn:  fieldColumn(targetPrimary),
			ConstraintKey: constraint,
		})
		src.fkIndex[column] = struct{}{}
	}
}

func ensureToManyColumn(src *entityMigration, entityIndex map[string]*entityMigration, edge dsl.Edge, srcPrimary dsl.Field) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	refColumn := edge.RefName
	if refColumn == "" {
		refColumn = fmt.Sprintf("%s_%s", toSnakeCase(src.Entity.Name), fieldColumn(srcPrimary))
	}
	fkField := makeForeignKeyField(refColumn, srcPrimary, edge.Nullable, edge.Unique)
	if idx, exists := target.fieldIndex[refColumn]; exists {
		existing := target.Fields[idx]
		if edge.Nullable && !existing.Nullable {
			existing.Nullable = true
		}
		if edge.Unique && !existing.IsUnique {
			existing.IsUnique = true
		}
		target.Fields[idx] = existing
	} else {
		target.Fields = append(target.Fields, fkField)
		target.fieldIndex[refColumn] = len(target.Fields) - 1
	}
	constraint := fmt.Sprintf("fk_%s_%s", pluralize(target.Entity.Name), refColumn)
	if _, exists := target.fkIndex[refColumn]; !exists {
		target.ForeignKeys = append(target.ForeignKeys, foreignKeySpec{
			Column:        refColumn,
			TargetTable:   pluralize(src.Entity.Name),
			TargetColumn:  fieldColumn(srcPrimary),
			ConstraintKey: constraint,
		})
		target.fkIndex[refColumn] = struct{}{}
	}
}

func ensureJoinTable(joinTables map[string]joinTableSpec, source Entity, entityIndex map[string]*entityMigration, edge dsl.Edge, srcPrimary dsl.Field) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	targetPrimary, ok := findPrimaryField(target.Entity)
	if !ok {
		return
	}
	joinName := edge.Through
	if joinName == "" {
		joinName = defaultJoinTableName(source.Name, edge.Target)
	}
	key := joinName
	if key == "" {
		key = joinName
	}
	if _, exists := joinTables[key]; exists {
		return
	}
	leftColumn := fmt.Sprintf("%s_%s", toSnakeCase(source.Name), fieldColumn(srcPrimary))
	rightColumn := fmt.Sprintf("%s_%s", toSnakeCase(edge.Target), fieldColumn(targetPrimary))
	joinTables[key] = joinTableSpec{
		Name: joinName,
		Left: joinTableColumn{
			Column:       leftColumn,
			TargetTable:  pluralize(source.Name),
			TargetColumn: fieldColumn(srcPrimary),
			SQLType:      fieldSQLType(srcPrimary),
		},
		Right: joinTableColumn{
			Column:       rightColumn,
			TargetTable:  pluralize(edge.Target),
			TargetColumn: fieldColumn(targetPrimary),
			SQLType:      fieldSQLType(targetPrimary),
		},
	}
}

func makeForeignKeyField(column string, refField dsl.Field, nullable, unique bool) dsl.Field {
	field := dsl.Field{
		Name:     column,
		Column:   column,
		Type:     refField.Type,
		GoType:   refField.GoType,
		Nullable: nullable,
		IsUnique: unique,
	}
	return field
}

func findPrimaryField(ent Entity) (dsl.Field, bool) {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return field, true
		}
	}
	if len(ent.Fields) > 0 {
		return ent.Fields[0], true
	}
	return dsl.Field{}, false
}

func fieldSQLType(field dsl.Field) string {
	switch field.Type {
	case dsl.TypeUUID:
		return "uuid"
	case dsl.TypeString:
		return "text"
	case dsl.TypeInt:
		return "bigint"
	case dsl.TypeFloat:
		return "double precision"
	case dsl.TypeBool:
		return "boolean"
	case dsl.TypeBytes:
		return "bytea"
	case dsl.TypeTime:
		return "timestamptz"
	case dsl.TypeJSON:
		return "jsonb"
	case dsl.TypeGeometry:
		return "geometry"
	case dsl.TypeGeography:
		return "geography"
	case dsl.TypeVector:
		if dim, ok := field.Annotations["vector_dim"].(int); ok && dim > 0 {
			return fmt.Sprintf("vector(%d)", dim)
		}
		return "vector"
	default:
		return "text"
	}
}

type projectConfig struct {
	Extensions struct {
		PostGIS   bool `yaml:"postgis"`
		PGVector  bool `yaml:"pgvector"`
		Timescale bool `yaml:"timescaledb"`
	} `yaml:"extensions"`
}

type extensionFlags struct {
	postgis   bool
	pgvector  bool
	timescale bool
}

func loadProjectConfig(root string) projectConfig {
	path := filepath.Join(root, "erm.yaml")
	raw, err := os.ReadFile(path)
	if err != nil {
		return projectConfig{}
	}
	var cfg projectConfig
	if err := yaml.Unmarshal(raw, &cfg); err != nil {
		return projectConfig{}
	}
	return cfg
}

func detectExtensionUsage(entities []Entity) extensionFlags {
	var flags extensionFlags
	for _, ent := range entities {
		for _, field := range ent.Fields {
			switch field.Type {
			case dsl.TypeGeometry, dsl.TypeGeography:
				flags.postgis = true
			case dsl.TypeVector:
				flags.pgvector = true
			}
			if ts, ok := field.Annotations["timeseries"].(bool); ok && ts {
				flags.timescale = true
			}
		}
	}
	return flags
}
