package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/deicod/erm/internal/orm/dsl"
	"gopkg.in/yaml.v3"
)

func ensureMigrationsPlaceholder(root string, entities []Entity) error {
	dir := filepath.Join(root, "migrations")
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(dir, "001_initial.sql")
	if _, err := os.ReadFile(path); err == nil {
		return nil
	}
	cfg := loadProjectConfig(root)
	usage := detectExtensionUsage(entities)
	flags := extensionFlags{
		postgis:   cfg.Extensions.PostGIS || usage.postgis,
		pgvector:  cfg.Extensions.PGVector || usage.pgvector,
		timescale: cfg.Extensions.Timescale || usage.timescale,
	}
	sql := renderInitialMigration(entities, flags)
	return writeFile(path, []byte(sql))
}

func renderInitialMigration(entities []Entity, flags extensionFlags) string {
	buf := &bytes.Buffer{}
	buf.WriteString("-- Code generated by erm.\n")
	buf.WriteString("-- Initial schema migration.\n\n")
	if flags.postgis {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS postgis;\n")
	}
	if flags.pgvector {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS vector;\n")
	}
	if flags.timescale {
		buf.WriteString("CREATE EXTENSION IF NOT EXISTS timescaledb;\n")
	}
	if flags.postgis || flags.pgvector || flags.timescale {
		buf.WriteString("\n")
	}
	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		table := pluralize(ent.Name)
		buf.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", table))
		cols := make([]string, 0, len(ent.Fields))
		primaryCols := make([]string, 0, 1)
		var hypertableColumn string
		for _, field := range ent.Fields {
			column := fieldColumn(field)
			colDef := fmt.Sprintf("    %s %s", column, fieldSQLType(field))
			if !field.Nullable {
				colDef += " NOT NULL"
			}
			if field.IsPrimary {
				primaryCols = append(primaryCols, column)
			}
			if field.HasDefaultNow {
				colDef += " DEFAULT now()"
			} else if field.DefaultExpr != "" {
				colDef += fmt.Sprintf(" DEFAULT %s", field.DefaultExpr)
			}
			if field.IsUnique {
				colDef += " UNIQUE"
			}
			if ts, ok := field.Annotations["timeseries"].(bool); ok && ts {
				hypertableColumn = column
			}
			cols = append(cols, colDef)
		}
		if len(primaryCols) > 0 {
			cols = append(cols, fmt.Sprintf("    PRIMARY KEY (%s)", strings.Join(primaryCols, ", ")))
		}
		buf.WriteString(strings.Join(cols, ",\n"))
		buf.WriteString("\n);\n\n")

		// Indexes
		for _, idx := range ent.Indexes {
			method := ""
			if idx.Method != "" {
				method = fmt.Sprintf(" USING %s", idx.Method)
			}
			unique := ""
			if idx.IsUnique {
				unique = " UNIQUE"
			}
			where := ""
			if idx.Where != "" {
				where = fmt.Sprintf(" WHERE %s", idx.Where)
			}
			cols := strings.Join(idx.Columns, ", ")
			buf.WriteString(fmt.Sprintf("CREATE%s INDEX IF NOT EXISTS %s ON %s%s (%s)%s;\n\n", unique, idx.Name, table, method, cols, where))
		}

		if hypertableColumn != "" {
			buf.WriteString(fmt.Sprintf("SELECT create_hypertable('%s', '%s', if_not_exists => TRUE);\n\n", table, hypertableColumn))
		}
	}
	return buf.String()
}

func fieldSQLType(field dsl.Field) string {
	switch field.Type {
	case dsl.TypeUUID:
		return "uuid"
	case dsl.TypeString:
		return "text"
	case dsl.TypeInt:
		return "bigint"
	case dsl.TypeFloat:
		return "double precision"
	case dsl.TypeBool:
		return "boolean"
	case dsl.TypeBytes:
		return "bytea"
	case dsl.TypeTime:
		return "timestamptz"
	case dsl.TypeJSON:
		return "jsonb"
	case dsl.TypeGeometry:
		return "geometry"
	case dsl.TypeGeography:
		return "geography"
	case dsl.TypeVector:
		if dim, ok := field.Annotations["vector_dim"].(int); ok && dim > 0 {
			return fmt.Sprintf("vector(%d)", dim)
		}
		return "vector"
	default:
		return "text"
	}
}

type projectConfig struct {
	Extensions struct {
		PostGIS   bool `yaml:"postgis"`
		PGVector  bool `yaml:"pgvector"`
		Timescale bool `yaml:"timescaledb"`
	} `yaml:"extensions"`
}

type extensionFlags struct {
	postgis   bool
	pgvector  bool
	timescale bool
}

func loadProjectConfig(root string) projectConfig {
	path := filepath.Join(root, "erm.yaml")
	raw, err := os.ReadFile(path)
	if err != nil {
		return projectConfig{}
	}
	var cfg projectConfig
	if err := yaml.Unmarshal(raw, &cfg); err != nil {
		return projectConfig{}
	}
	return cfg
}

func detectExtensionUsage(entities []Entity) extensionFlags {
	var flags extensionFlags
	for _, ent := range entities {
		for _, field := range ent.Fields {
			switch field.Type {
			case dsl.TypeGeometry, dsl.TypeGeography:
				flags.postgis = true
			case dsl.TypeVector:
				flags.pgvector = true
			}
			if ts, ok := field.Annotations["timeseries"].(bool); ok && ts {
				flags.timescale = true
			}
		}
	}
	return flags
}
