package generator

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/deicod/erm/internal/orm/dsl"
)

func writeORMArtifacts(root string, entities []Entity) error {
	if err := writeRegistry(root, entities); err != nil {
		return err
	}
	if err := writeModels(root, entities); err != nil {
		return err
	}
	if err := writeClients(root, entities); err != nil {
		return err
	}
	return nil
}

func writeRegistry(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")
	fmt.Fprintf(buf, "import (\n    \"github.com/deicod/erm/internal/orm/dsl\"\n    \"github.com/deicod/erm/internal/orm/runtime\"\n)\n\n")
	fmt.Fprintf(buf, "var Registry = runtime.Registry{\n    Entities: map[string]runtime.EntitySpec{\n")
	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "        \"%s\": {\n", ent.Name)
		fmt.Fprintf(buf, "            Name: \"%s\",\n", ent.Name)
		fmt.Fprintf(buf, "            Table: \"%s\",\n", pluralize(ent.Name))
		fmt.Fprintf(buf, "            Fields: []runtime.FieldSpec{\n")
		for _, field := range ent.Fields {
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, GoType: %q, Type: %s, Primary: %t, Nullable: %t, Unique: %t, DefaultNow: %t, UpdateNow: %t, DefaultExpr: %q, Annotations: %s},\n",
				field.Name, fieldColumn(field), field.GoType, fieldTypeLiteral(field.Type), field.IsPrimary, field.Nullable, field.IsUnique, field.HasDefaultNow, field.HasUpdateNow, field.DefaultExpr, mapLiteral(field.Annotations))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Edges: []runtime.EdgeSpec{\n")
		for _, edge := range ent.Edges {
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, RefName: %q, Through: %q, Target: %q, Kind: %s, Nullable: %t, Unique: %t, Annotations: %s, Inverse: %q},\n",
				edge.Name, edgeColumn(edge), edge.RefName, edge.Through, edge.Target, edgeKindLiteral(edge.Kind), edge.Nullable, edge.Unique, mapLiteral(edge.Annotations), edge.InverseName)
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Indexes: []runtime.IndexSpec{\n")
		for _, idx := range ent.Indexes {
			fmt.Fprintf(buf, "                {Name: %q, Columns: %s, Unique: %t, Where: %q, Method: %q, NullsNotDistinct: %t, Annotations: %s},\n",
				idx.Name, quoteStringSlice(idx.Columns), idx.IsUnique, idx.Where, idx.Method, idx.NullsNotDistinct, mapLiteral(idx.Annotations))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "        },\n")
	}
	fmt.Fprintf(buf, "    },\n}\n")
	path := filepath.Join(root, "internal", "orm", "gen", "registry_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func writeModels(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	imports := collectModelImports(entities)
	if len(imports) > 0 {
		fmt.Fprintf(buf, "import (\n")
		sort.Strings(imports)
		for _, imp := range imports {
			fmt.Fprintf(buf, "    \"%s\"\n", imp)
		}
		fmt.Fprintf(buf, ")\n\n")
	}

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "type %s struct {\n", ent.Name)
		for _, field := range ent.Fields {
			goType := field.GoType
			if goType == "" {
				goType = defaultGoType(field.Type)
			}
			fmt.Fprintf(buf, "    %s %s `db:\"%s\" json:\"%s\"`\n", exportName(field.Name), goType, fieldColumn(field), jsonName(field.Name))
		}
		if len(ent.Edges) > 0 {
			fmt.Fprintf(buf, "    Edges *%sEdges `json:\"edges,omitempty\"`\n", ent.Name)
		}
		fmt.Fprintf(buf, "}\n\n")

		if len(ent.Edges) > 0 {
			emitEdgesStruct(buf, ent)
			emitEdgeAccessors(buf, ent)
		}
	}

	path := filepath.Join(root, "internal", "orm", "gen", "models_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func fieldColumn(field dsl.Field) string {
	if field.Column != "" {
		return field.Column
	}
	return toSnakeCase(field.Name)
}

func edgeColumn(edge dsl.Edge) string {
	if edge.Column != "" {
		return edge.Column
	}
	switch edge.Kind {
	case dsl.EdgeToOne:
		return toSnakeCase(edge.Name) + "_id"
	default:
		return toSnakeCase(edge.Name)
	}
}

func exportName(name string) string {
	if name == "" {
		return ""
	}
	if name == "id" || name == "ID" {
		return "ID"
	}
	if strings.Contains(name, "_") {
		parts := strings.Split(name, "_")
		for i, p := range parts {
			if p == "" {
				continue
			}
			parts[i] = capitalize(p)
		}
		return strings.Join(parts, "")
	}
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func capitalize(in string) string {
	if in == "" {
		return in
	}
	runes := []rune(in)
	runes[0] = unicode.ToUpper(runes[0])
	for i := 1; i < len(runes); i++ {
		runes[i] = unicode.ToLower(runes[i])
	}
	return string(runes)
}

func jsonName(name string) string {
	out := toSnakeCase(name)
	if out == "" {
		return name
	}
	return out
}

func quoteStringSlice(items []string) string {
	if len(items) == 0 {
		return "nil"
	}
	parts := make([]string, len(items))
	for i, item := range items {
		parts[i] = fmt.Sprintf("\"%s\"", item)
	}
	return fmt.Sprintf("[]string{%s}", strings.Join(parts, ", "))
}

func defaultGoType(ft dsl.FieldType) string {
	switch ft {
	case dsl.TypeUUID, dsl.TypeString:
		return "string"
	case dsl.TypeBool:
		return "bool"
	case dsl.TypeInt:
		return "int"
	case dsl.TypeFloat:
		return "float64"
	case dsl.TypeBytes:
		return "[]byte"
	case dsl.TypeTime:
		return "time.Time"
	case dsl.TypeJSON:
		return "json.RawMessage"
	case dsl.TypeGeometry, dsl.TypeGeography:
		return "[]byte"
	case dsl.TypeVector:
		return "[]float32"
	default:
		return "string"
	}
}

func collectModelImports(entities []Entity) []string {
	set := map[string]struct{}{}
	for _, ent := range entities {
		for _, field := range ent.Fields {
			goType := field.GoType
			if goType == "" {
				goType = defaultGoType(field.Type)
			}
			switch goType {
			case "time.Time":
				set["time"] = struct{}{}
			case "json.RawMessage":
				set["encoding/json"] = struct{}{}
			}
		}
	}
	imports := make([]string, 0, len(set))
	for imp := range set {
		imports = append(imports, imp)
	}
	return imports
}

func writeClients(root string, entities []Entity) error {
	path := filepath.Join(root, "internal", "orm", "gen", "client_gen.go")
	if len(entities) == 0 {
		src := []byte("// Code generated by erm. DO NOT EDIT.\npackage gen\n")
		return writeGoFile(path, src)
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	needsTime := false
	needsID := false
	hasEdges := false
	for _, ent := range entities {
		for _, field := range ent.Fields {
			if field.HasDefaultNow || field.HasUpdateNow {
				needsTime = true
			}
			if field.IsPrimary && field.Type == dsl.TypeUUID {
				needsID = true
			}
		}
		if len(ent.Edges) > 0 {
			hasEdges = true
		}
	}

	imports := []string{"context", "errors"}
	if hasEdges {
		imports = append(imports, "fmt", "strings")
	}
	if needsTime {
		imports = append(imports, "time")
	}
	imports = append(imports,
		"github.com/jackc/pgx/v5",
		"github.com/deicod/erm/internal/orm/pg",
	)
	if needsID {
		imports = append(imports, "github.com/deicod/erm/internal/orm/id")
	}

	sort.Strings(imports)
	fmt.Fprintf(buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(buf, "    \"%s\"\n", imp)
	}
	fmt.Fprintf(buf, ")\n\n")

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })

	fmt.Fprintf(buf, "type Client struct {\n    db *pg.DB\n}\n\n")
	fmt.Fprintf(buf, "func NewClient(db *pg.DB) *Client {\n    return &Client{db: db}\n}\n\n")

	entityIndex := make(map[string]Entity, len(entities))
	for _, ent := range entities {
		entityIndex[ent.Name] = ent
	}

	for _, ent := range entities {
		fmt.Fprintf(buf, "func (c *Client) %s() *%sClient {\n    return &%sClient{db: c.db}\n}\n\n", exportName(pluralize(ent.Name)), ent.Name, ent.Name)
	}

	for _, ent := range entities {
		emitEntityClients(buf, ent, entityIndex)
	}

	if hasEdges {
		emitRelationshipHelpers(buf)
	}

	return writeGoFile(path, buf.Bytes())
}

func emitEntityClients(buf *bytes.Buffer, ent Entity, entityIndex map[string]Entity) {
	name := ent.Name
	lower := strings.ToLower(name)
	columns := entityColumns(ent)
	returning := strings.Join(columns, ", ")
	insertSQL := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", pluralize(name), strings.Join(columns, ", "), placeholders(len(columns)), returning)
	selectSQL := fmt.Sprintf("SELECT %s FROM %s WHERE %s = $1", returning, pluralize(name), primaryColumn(ent))
	listSQL := fmt.Sprintf("SELECT %s FROM %s ORDER BY %s LIMIT $1 OFFSET $2", returning, pluralize(name), primaryColumn(ent))
	countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s", pluralize(name))

	updateCols := updatableColumns(ent)
	updateSQL := ""
	if len(updateCols) > 0 {
		assignments := make([]string, len(updateCols))
		for i, col := range updateCols {
			assignments[i] = fmt.Sprintf("%s = $%d", col, i+1)
		}
		updateSQL = fmt.Sprintf("UPDATE %s SET %s WHERE %s = $%d RETURNING %s", pluralize(name), strings.Join(assignments, ", "), primaryColumn(ent), len(updateCols)+1, returning)
	}

	fmt.Fprintf(buf, "const %sInsertQuery = `%s`\n", lower, insertSQL)
	fmt.Fprintf(buf, "const %sSelectQuery = `%s`\n", lower, selectSQL)
	fmt.Fprintf(buf, "const %sListQuery = `%s`\n", lower, listSQL)
	if updateSQL != "" {
		fmt.Fprintf(buf, "const %sUpdateQuery = `%s`\n", lower, updateSQL)
	}
	fmt.Fprintf(buf, "const %sCountQuery = `%s`\n", lower, countSQL)
	fmt.Fprintf(buf, "const %sDeleteQuery = `DELETE FROM %s WHERE %s = $1`\n\n", lower, pluralize(name), primaryColumn(ent))

	fmt.Fprintf(buf, "type %sClient struct {\n    db *pg.DB\n}\n\n", name)

	emitCreateMethod(buf, ent)
	emitByIDMethod(buf, ent)
	emitListMethod(buf, ent)
	emitCountMethod(buf, ent)
	if updateSQL != "" {
		emitUpdateMethod(buf, ent)
	}
	emitDeleteMethod(buf, ent)
	emitEdgeLoaders(buf, ent, entityIndex)
}

func emitCreateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Create(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasDefaultNow || field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}

	for _, field := range ent.Fields {
		fieldName := exportName(field.Name)
		switch {
		case field.IsPrimary && field.Type == dsl.TypeUUID:
			fmt.Fprintf(buf, "    if input.%s == \"\" {\n", fieldName)
			fmt.Fprintf(buf, "        v, err := id.NewV7()\n")
			fmt.Fprintf(buf, "        if err != nil { return nil, err }\n")
			fmt.Fprintf(buf, "        input.%s = v\n", fieldName)
			fmt.Fprintf(buf, "    }\n")
		}
		if field.HasDefaultNow {
			fmt.Fprintf(buf, "    if input.%s.IsZero() { input.%s = now }\n", fieldName, fieldName)
		}
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", fieldName)
		}
	}

	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sInsertQuery", strings.ToLower(ent.Name))
	for _, field := range ent.Fields {
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ")\n")
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitByIDMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) ByID(ctx context.Context, id string) (*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sSelectQuery, id)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        if errors.Is(err, pgx.ErrNoRows) {\n            return nil, nil\n        }\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitListMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) List(ctx context.Context, limit, offset int) ([]*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if limit <= 0 { limit = 20 }\n")
	fmt.Fprintf(buf, "    if offset < 0 { offset = 0 }\n")
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, %sListQuery, limit, offset)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    if err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var result []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(", ent.Name)
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&item.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n            return nil, err\n        }\n        result = append(result, item)\n    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    return result, nil\n}\n\n")
}

func emitCountMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Count(ctx context.Context) (int, error) {\n", ent.Name)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sCountQuery)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    var total int\n")
	fmt.Fprintf(buf, "    if err := row.Scan(&total); err != nil {\n        return 0, err\n    }\n")
	fmt.Fprintf(buf, "    return total, nil\n}\n\n")
}

func emitUpdateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Update(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")
	fmt.Fprintf(buf, "    if input.%s == \"\" {\n        return nil, errors.New(\"id is required\")\n    }\n", exportName(primaryField(ent).Name))

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", exportName(field.Name))
		}
	}

	updateCols := updatableColumns(ent)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sUpdateQuery", strings.ToLower(ent.Name))
	for _, col := range updateCols {
		field := findFieldByColumn(ent, col)
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ", input.%s)\n", exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitDeleteMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Delete(ctx context.Context, id string) error {\n", ent.Name)
	fmt.Fprintf(buf, "    _, err := c.db.Pool.Exec(ctx, %sDeleteQuery, id)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    return err\n}\n\n")
}

func emitEdgeLoaders(buf *bytes.Buffer, ent Entity, entityIndex map[string]Entity) {
	if len(ent.Edges) == 0 {
		return
	}
	for _, edge := range ent.Edges {
		switch edge.Kind {
		case dsl.EdgeToOne:
			emitToOneLoader(buf, ent, edge, entityIndex)
		case dsl.EdgeToMany:
			emitToManyLoader(buf, ent, edge, entityIndex)
		case dsl.EdgeManyToMany:
			emitManyToManyLoader(buf, ent, edge, entityIndex)
		}
	}
}

func emitToOneLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	targetPrimary := primaryField(target)
	fkField, found := fieldByColumn(source, edgeColumn(edge))
	if !found {
		return
	}
	keyType := goTypeForField(fkField)
	targetKeyField := exportName(targetPrimary.Name)
	fkFieldName := exportName(fkField.Name)
	columns := entityColumns(target)
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s IN (%%s)", strings.Join(columns, ", "), pluralize(edge.Target), fieldColumn(targetPrimary))
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        edges.markLoaded(%q)\n        fk := parent.%s\n        if isZero(fk) {\n            edges.%s = nil\n            continue\n        }\n        if _, ok := seen[fk]; !ok {\n            seen[fk] = struct{}{}\n            keys = append(keys, fk)\n        }\n    }\n", source.Name, edge.Name, fkFieldName, exportName(edge.Name))
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    related := make(map[keyType]*%s, len(keys))\n", edge.Target)
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        key := item.%s\n        related[key] = item\n    }\n", edge.Target, scanArgs(target), targetKeyField)
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        fk := parent.%s\n        edges := ensure%sEdges(parent)\n        if isZero(fk) {\n            edges.%s = nil\n            continue\n        }\n        if item, ok := related[fk]; ok {\n            edges.%s = item\n        } else {\n            edges.%s = nil\n        }\n    }\n", fkFieldName, source.Name, exportName(edge.Name), exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitToManyLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	sourcePrimary := primaryField(source)
	targetRefColumn := edgeRefColumn(source, edge, sourcePrimary)
	if targetRefColumn == "" {
		return
	}
	refField, found := fieldByColumn(target, targetRefColumn)
	if !found {
		return
	}
	keyType := goTypeForField(sourcePrimary)
	sourceKeyName := exportName(sourcePrimary.Name)
	refFieldName := exportName(refField.Name)
	columns := entityColumns(target)
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s IN (%%s)", strings.Join(columns, ", "), pluralize(edge.Target), targetRefColumn)
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    buckets := make(map[keyType][]*%s, len(parents))\n", source.Name)
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        key := parent.%s\n        if isZero(key) {\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n            continue\n        }\n        if _, ok := seen[key]; !ok {\n            seen[key] = struct{}{}\n            keys = append(keys, key)\n        }\n        buckets[key] = append(buckets[key], parent)\n    }\n", sourceKeyName, source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        for _, parent := range parents {\n            if parent == nil {\n                continue\n            }\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n        }\n        return nil\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        owner := item.%s\n        parents, ok := buckets[owner]\n        if !ok {\n            continue\n        }\n        for _, parent := range parents {\n            edges := ensure%sEdges(parent)\n            edges.%s = append(edges.%s, item)\n        }\n    }\n", edge.Target, scanArgs(target), refFieldName, source.Name, exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        if edges.%s == nil {\n            edges.%s = []*%s{}\n        }\n        edges.markLoaded(%q)\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitManyToManyLoader(buf *bytes.Buffer, source Entity, edge dsl.Edge, entityIndex map[string]Entity) {
	target, ok := entityIndex[edge.Target]
	if !ok {
		return
	}
	sourcePrimary := primaryField(source)
	targetPrimary := primaryField(target)
	joinTable, leftColumn, rightColumn := manyToManyJoinSpec(source, sourcePrimary, edge, targetPrimary)
	if joinTable == "" {
		return
	}
	keyType := goTypeForField(sourcePrimary)
	sourceKeyName := exportName(sourcePrimary.Name)
	columns := entityColumns(target)
	selectCols := append([]string{}, columns...)
	selectCols = append(selectCols, fmt.Sprintf("jt.%s", leftColumn))
	query := fmt.Sprintf("SELECT %s FROM %s AS t JOIN %s AS jt ON t.%s = jt.%s WHERE jt.%s IN (%%s)", strings.Join(selectCols, ", "), pluralize(edge.Target), joinTable, fieldColumn(targetPrimary), rightColumn, leftColumn)
	constName := fmt.Sprintf("%s%sRelationQuery", strings.ToLower(source.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "const %s = `%s`\n", constName, query)

	fmt.Fprintf(buf, "func (c *%sClient) Load%s(ctx context.Context, parents ...*%s) error {\n", source.Name, exportName(edge.Name), source.Name)
	fmt.Fprintf(buf, "    if len(parents) == 0 {\n        return nil\n    }\n")
	fmt.Fprintf(buf, "    type keyType = %s\n", keyType)
	fmt.Fprintf(buf, "    keys := make([]keyType, 0, len(parents))\n")
	fmt.Fprintf(buf, "    seen := make(map[keyType]struct{}, len(parents))\n")
	fmt.Fprintf(buf, "    buckets := make(map[keyType][]*%s, len(parents))\n", source.Name)
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        key := parent.%s\n        if isZero(key) {\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n            continue\n        }\n        if _, ok := seen[key]; !ok {\n            seen[key] = struct{}{}\n            keys = append(keys, key)\n        }\n        buckets[key] = append(buckets[key], parent)\n    }\n", sourceKeyName, source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    if len(keys) == 0 {\n        for _, parent := range parents {\n            if parent == nil {\n                continue\n            }\n            edges := ensure%sEdges(parent)\n            if edges.%s == nil {\n                edges.%s = []*%s{}\n            }\n            edges.markLoaded(%q)\n        }\n        return nil\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    sql, args := buildInQuery(%s, keys)\n", constName)
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, sql, args...)\n    if err != nil {\n        return err\n    }\n    defer rows.Close()\n")
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        var owner keyType\n        if err := rows.Scan(%s); err != nil {\n            return err\n        }\n        parents, ok := buckets[owner]\n        if !ok {\n            continue\n        }\n        for _, parent := range parents {\n            edges := ensure%sEdges(parent)\n            edges.%s = append(edges.%s, item)\n        }\n    }\n", edge.Target, scanArgsWithExtra(target, "&owner"), source.Name, exportName(edge.Name), exportName(edge.Name))
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil {\n        return err\n    }\n")
	fmt.Fprintf(buf, "    for _, parent := range parents {\n        if parent == nil {\n            continue\n        }\n        edges := ensure%sEdges(parent)\n        if edges.%s == nil {\n            edges.%s = []*%s{}\n        }\n        edges.markLoaded(%q)\n    }\n", source.Name, exportName(edge.Name), exportName(edge.Name), edge.Target, edge.Name)
	fmt.Fprintf(buf, "    return nil\n}\n\n")
}

func emitRelationshipHelpers(buf *bytes.Buffer) {
	fmt.Fprintf(buf, "func buildInQuery[T any](base string, values []T) (string, []any) {\n")
	fmt.Fprintf(buf, "    if len(values) == 0 {\n        return base, nil\n    }\n")
	fmt.Fprintf(buf, "    placeholders := make([]string, len(values))\n")
	fmt.Fprintf(buf, "    args := make([]any, len(values))\n")
	fmt.Fprintf(buf, "    for i := range values {\n        placeholders[i] = fmt.Sprintf(\"$%%d\", i+1)\n        args[i] = values[i]\n    }\n")
	fmt.Fprintf(buf, "    return fmt.Sprintf(base, strings.Join(placeholders, %q)), args\n}\n\n", ", ")

	fmt.Fprintf(buf, "func isZero[T comparable](v T) bool {\n    var zero T\n    return v == zero\n}\n\n")
}

func scanArgs(ent Entity) string { return strings.Join(scanArgsForVar(ent, "item"), ", ") }

func scanArgsWithExtra(ent Entity, extra string) string {
	parts := scanArgsForVar(ent, "item")
	if extra != "" {
		parts = append(parts, extra)
	}
	return strings.Join(parts, ", ")
}

func scanArgsForVar(ent Entity, varName string) []string {
	parts := make([]string, len(ent.Fields))
	for i, field := range ent.Fields {
		parts[i] = fmt.Sprintf("&%s.%s", varName, exportName(field.Name))
	}
	return parts
}

func fieldByColumn(ent Entity, column string) (dsl.Field, bool) {
	for _, field := range ent.Fields {
		if fieldColumn(field) == column {
			return field, true
		}
	}
	return dsl.Field{}, false
}

func goTypeForField(field dsl.Field) string {
	if field.GoType != "" {
		return field.GoType
	}
	return defaultGoType(field.Type)
}

func edgeRefColumn(source Entity, edge dsl.Edge, primary dsl.Field) string {
	if edge.RefName != "" {
		return edge.RefName
	}
	if primary.Name == "" {
		return ""
	}
	return fmt.Sprintf("%s_%s", toSnakeCase(source.Name), fieldColumn(primary))
}

func manyToManyJoinSpec(source Entity, sourcePrimary dsl.Field, edge dsl.Edge, targetPrimary dsl.Field) (string, string, string) {
	joinTable := edge.Through
	if joinTable == "" {
		joinTable = defaultJoinTableName(source.Name, edge.Target)
	}
	if joinTable == "" {
		return "", "", ""
	}
	left := fmt.Sprintf("%s_%s", toSnakeCase(source.Name), fieldColumn(sourcePrimary))
	right := fmt.Sprintf("%s_%s", toSnakeCase(edge.Target), fieldColumn(targetPrimary))
	return joinTable, left, right
}

func emitEdgesStruct(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "type %sEdges struct {\n", ent.Name)
	fmt.Fprintf(buf, "    loaded map[string]bool\n")
	for _, edge := range ent.Edges {
		fieldName := exportName(edge.Name)
		jsonTag := jsonName(edge.Name)
		switch edge.Kind {
		case dsl.EdgeToOne:
			fmt.Fprintf(buf, "    %s *%s `json:\"%s,omitempty\"`\n", fieldName, edge.Target, jsonTag)
		case dsl.EdgeToMany, dsl.EdgeManyToMany:
			fmt.Fprintf(buf, "    %s []*%s `json:\"%s,omitempty\"`\n", fieldName, edge.Target, jsonTag)
		}
	}
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (e *%sEdges) markLoaded(name string) {\n", ent.Name)
	fmt.Fprintf(buf, "    if e == nil {\n        return\n    }\n")
	fmt.Fprintf(buf, "    if e.loaded == nil {\n        e.loaded = make(map[string]bool)\n    }\n")
	fmt.Fprintf(buf, "    e.loaded[name] = true\n}\n\n")
}

func emitEdgeAccessors(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func ensure%sEdges(m *%s) *%sEdges {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if m.Edges == nil {\n        m.Edges = &%sEdges{}\n    }\n", ent.Name)
	fmt.Fprintf(buf, "    if m.Edges.loaded == nil {\n        m.Edges.loaded = make(map[string]bool)\n    }\n")
	fmt.Fprintf(buf, "    return m.Edges\n}\n\n")

	fmt.Fprintf(buf, "func (m *%s) EdgeLoaded(name string) bool {\n", ent.Name)
	fmt.Fprintf(buf, "    if m == nil || m.Edges == nil || m.Edges.loaded == nil {\n        return false\n    }\n")
	fmt.Fprintf(buf, "    return m.Edges.loaded[name]\n}\n\n")

	for _, edge := range ent.Edges {
		fieldName := exportName(edge.Name)
		jsonTag := edge.Name
		switch edge.Kind {
		case dsl.EdgeToOne:
			fmt.Fprintf(buf, "func (m *%s) Set%s(value *%s) {\n", ent.Name, fieldName, edge.Target)
			fmt.Fprintf(buf, "    edges := ensure%sEdges(m)\n", ent.Name)
			fmt.Fprintf(buf, "    edges.%s = value\n", fieldName)
			fmt.Fprintf(buf, "    edges.markLoaded(%q)\n}\n\n", jsonTag)
		case dsl.EdgeToMany, dsl.EdgeManyToMany:
			fmt.Fprintf(buf, "func (m *%s) Set%s(values []*%s) {\n", ent.Name, fieldName, edge.Target)
			fmt.Fprintf(buf, "    edges := ensure%sEdges(m)\n", ent.Name)
			fmt.Fprintf(buf, "    if values == nil {\n        values = []*%s{}\n    }\n", edge.Target)
			fmt.Fprintf(buf, "    edges.%s = values\n", fieldName)
			fmt.Fprintf(buf, "    edges.markLoaded(%q)\n}\n\n", jsonTag)
		}
	}
}

func entityColumns(ent Entity) []string {
	cols := make([]string, len(ent.Fields))
	for i, field := range ent.Fields {
		cols[i] = fieldColumn(field)
	}
	return cols
}

func placeholders(n int) string {
	items := make([]string, n)
	for i := 0; i < n; i++ {
		items[i] = fmt.Sprintf("$%d", i+1)
	}
	return strings.Join(items, ", ")
}

func primaryColumn(ent Entity) string {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return fieldColumn(field)
		}
	}
	return fieldColumn(ent.Fields[0])
}

func primaryField(ent Entity) dsl.Field {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return field
		}
	}
	return ent.Fields[0]
}

func updatableColumns(ent Entity) []string {
	cols := []string{}
	for _, field := range ent.Fields {
		if field.IsPrimary {
			continue
		}
		if field.HasDefaultNow && !field.HasUpdateNow {
			continue
		}
		cols = append(cols, fieldColumn(field))
	}
	return cols
}

func findFieldByColumn(ent Entity, column string) dsl.Field {
	for _, field := range ent.Fields {
		if fieldColumn(field) == column {
			return field
		}
	}
	return ent.Fields[0]
}

func fieldTypeLiteral(ft dsl.FieldType) string {
	switch ft {
	case dsl.TypeUUID:
		return "dsl.TypeUUID"
	case dsl.TypeString:
		return "dsl.TypeString"
	case dsl.TypeInt:
		return "dsl.TypeInt"
	case dsl.TypeFloat:
		return "dsl.TypeFloat"
	case dsl.TypeBool:
		return "dsl.TypeBool"
	case dsl.TypeBytes:
		return "dsl.TypeBytes"
	case dsl.TypeTime:
		return "dsl.TypeTime"
	case dsl.TypeJSON:
		return "dsl.TypeJSON"
	default:
		return fmt.Sprintf("dsl.FieldType(%q)", string(ft))
	}
}

func edgeKindLiteral(kind dsl.EdgeKind) string {
	switch kind {
	case dsl.EdgeToOne:
		return "dsl.EdgeToOne"
	case dsl.EdgeToMany:
		return "dsl.EdgeToMany"
	case dsl.EdgeManyToMany:
		return "dsl.EdgeManyToMany"
	default:
		return fmt.Sprintf("dsl.EdgeKind(%q)", string(kind))
	}
}

func mapLiteral(input map[string]any) string {
	if len(input) == 0 {
		return "nil"
	}
	keys := make([]string, 0, len(input))
	for k := range input {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	parts := make([]string, 0, len(keys))
	for _, key := range keys {
		parts = append(parts, fmt.Sprintf("%q: %#v", key, input[key]))
	}
	return fmt.Sprintf("map[string]any{%s}", strings.Join(parts, ", "))
}
