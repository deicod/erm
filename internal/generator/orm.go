package generator

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/deicod/erm/internal/orm/dsl"
)

func writeORMArtifacts(root string, entities []Entity) error {
	if err := writeRegistry(root, entities); err != nil {
		return err
	}
	if err := writeModels(root, entities); err != nil {
		return err
	}
	if err := writeClients(root, entities); err != nil {
		return err
	}
	return nil
}

func writeRegistry(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")
	fmt.Fprintf(buf, "import (\n    \"github.com/deicod/erm/internal/orm/dsl\"\n    \"github.com/deicod/erm/internal/orm/runtime\"\n)\n\n")
	fmt.Fprintf(buf, "var Registry = runtime.Registry{\n    Entities: map[string]runtime.EntitySpec{\n")
	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "        \"%s\": {\n", ent.Name)
		fmt.Fprintf(buf, "            Name: \"%s\",\n", ent.Name)
		fmt.Fprintf(buf, "            Table: \"%s\",\n", pluralize(ent.Name))
		fmt.Fprintf(buf, "            Fields: []runtime.FieldSpec{\n")
		for _, field := range ent.Fields {
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, GoType: %q, Type: %s, Primary: %t, Nullable: %t, Unique: %t, DefaultNow: %t, UpdateNow: %t, DefaultExpr: %q, Annotations: %s},\n",
				field.Name, fieldColumn(field), field.GoType, fieldTypeLiteral(field.Type), field.IsPrimary, field.Nullable, field.IsUnique, field.HasDefaultNow, field.HasUpdateNow, field.DefaultExpr, mapLiteral(field.Annotations))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Edges: []runtime.EdgeSpec{\n")
		for _, edge := range ent.Edges {
			fmt.Fprintf(buf, "                {Name: %q, Column: %q, RefName: %q, Through: %q, Target: %q, Kind: %s, Nullable: %t, Unique: %t, Annotations: %s, Inverse: %q},\n",
				edge.Name, edgeColumn(edge), edge.RefName, edge.Through, edge.Target, edgeKindLiteral(edge.Kind), edge.Nullable, edge.Unique, mapLiteral(edge.Annotations), edge.InverseName)
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "            Indexes: []runtime.IndexSpec{\n")
		for _, idx := range ent.Indexes {
			fmt.Fprintf(buf, "                {Name: %q, Columns: %s, Unique: %t, Where: %q, Method: %q, NullsNotDistinct: %t, Annotations: %s},\n",
				idx.Name, quoteStringSlice(idx.Columns), idx.IsUnique, idx.Where, idx.Method, idx.NullsNotDistinct, mapLiteral(idx.Annotations))
		}
		fmt.Fprintf(buf, "            },\n")
		fmt.Fprintf(buf, "        },\n")
	}
	fmt.Fprintf(buf, "    },\n}\n")
	path := filepath.Join(root, "internal", "orm", "gen", "registry_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func writeModels(root string, entities []Entity) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	imports := collectModelImports(entities)
	if len(imports) > 0 {
		fmt.Fprintf(buf, "import (\n")
		sort.Strings(imports)
		for _, imp := range imports {
			fmt.Fprintf(buf, "    \"%s\"\n", imp)
		}
		fmt.Fprintf(buf, ")\n\n")
	}

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })
	for _, ent := range entities {
		fmt.Fprintf(buf, "type %s struct {\n", ent.Name)
		for _, field := range ent.Fields {
			goType := field.GoType
			if goType == "" {
				goType = defaultGoType(field.Type)
			}
			fmt.Fprintf(buf, "    %s %s `db:\"%s\" json:\"%s\"`\n", exportName(field.Name), goType, fieldColumn(field), jsonName(field.Name))
		}
		fmt.Fprintf(buf, "}\n\n")
	}

	path := filepath.Join(root, "internal", "orm", "gen", "models_gen.go")
	return writeGoFile(path, buf.Bytes())
}

func fieldColumn(field dsl.Field) string {
	if field.Column != "" {
		return field.Column
	}
	return toSnakeCase(field.Name)
}

func edgeColumn(edge dsl.Edge) string {
	if edge.Column != "" {
		return edge.Column
	}
	switch edge.Kind {
	case dsl.EdgeToOne:
		return toSnakeCase(edge.Name) + "_id"
	default:
		return toSnakeCase(edge.Name)
	}
}

func exportName(name string) string {
	if name == "" {
		return ""
	}
	if name == "id" || name == "ID" {
		return "ID"
	}
	if strings.Contains(name, "_") {
		parts := strings.Split(name, "_")
		for i, p := range parts {
			if p == "" {
				continue
			}
			parts[i] = capitalize(p)
		}
		return strings.Join(parts, "")
	}
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func capitalize(in string) string {
	if in == "" {
		return in
	}
	runes := []rune(in)
	runes[0] = unicode.ToUpper(runes[0])
	for i := 1; i < len(runes); i++ {
		runes[i] = unicode.ToLower(runes[i])
	}
	return string(runes)
}

func jsonName(name string) string {
	out := toSnakeCase(name)
	if out == "" {
		return name
	}
	return out
}

func quoteStringSlice(items []string) string {
	if len(items) == 0 {
		return "nil"
	}
	parts := make([]string, len(items))
	for i, item := range items {
		parts[i] = fmt.Sprintf("\"%s\"", item)
	}
	return fmt.Sprintf("[]string{%s}", strings.Join(parts, ", "))
}

func defaultGoType(ft dsl.FieldType) string {
	switch ft {
	case dsl.TypeUUID, dsl.TypeString:
		return "string"
	case dsl.TypeBool:
		return "bool"
	case dsl.TypeInt:
		return "int"
	case dsl.TypeFloat:
		return "float64"
	case dsl.TypeBytes:
		return "[]byte"
	case dsl.TypeTime:
		return "time.Time"
	case dsl.TypeJSON:
		return "json.RawMessage"
	case dsl.TypeGeometry, dsl.TypeGeography:
		return "[]byte"
	case dsl.TypeVector:
		return "[]float32"
	default:
		return "string"
	}
}

func collectModelImports(entities []Entity) []string {
	set := map[string]struct{}{}
	for _, ent := range entities {
		for _, field := range ent.Fields {
			goType := field.GoType
			if goType == "" {
				goType = defaultGoType(field.Type)
			}
			switch goType {
			case "time.Time":
				set["time"] = struct{}{}
			case "json.RawMessage":
				set["encoding/json"] = struct{}{}
			}
		}
	}
	imports := make([]string, 0, len(set))
	for imp := range set {
		imports = append(imports, imp)
	}
	return imports
}

func writeClients(root string, entities []Entity) error {
	path := filepath.Join(root, "internal", "orm", "gen", "client_gen.go")
	if len(entities) == 0 {
		src := []byte("// Code generated by erm. DO NOT EDIT.\npackage gen\n")
		return writeGoFile(path, src)
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by erm. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package gen\n\n")

	needsTime := false
	needsID := false
	for _, ent := range entities {
		for _, field := range ent.Fields {
			if field.HasDefaultNow || field.HasUpdateNow {
				needsTime = true
			}
			if field.IsPrimary && field.Type == dsl.TypeUUID {
				needsID = true
			}
		}
	}

	imports := []string{"context", "errors"}
	if needsTime {
		imports = append(imports, "time")
	}
	imports = append(imports,
		"github.com/jackc/pgx/v5",
		"github.com/deicod/erm/internal/orm/pg",
	)
	if needsID {
		imports = append(imports, "github.com/deicod/erm/internal/orm/id")
	}

	sort.Strings(imports)
	fmt.Fprintf(buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(buf, "    \"%s\"\n", imp)
	}
	fmt.Fprintf(buf, ")\n\n")

	sort.Slice(entities, func(i, j int) bool { return entities[i].Name < entities[j].Name })

	fmt.Fprintf(buf, "type Client struct {\n    db *pg.DB\n}\n\n")
	fmt.Fprintf(buf, "func NewClient(db *pg.DB) *Client {\n    return &Client{db: db}\n}\n\n")

	for _, ent := range entities {
		fmt.Fprintf(buf, "func (c *Client) %s() *%sClient {\n    return &%sClient{db: c.db}\n}\n\n", exportName(pluralize(ent.Name)), ent.Name, ent.Name)
	}

	for _, ent := range entities {
		emitEntityClients(buf, ent)
	}

	return writeGoFile(path, buf.Bytes())
}

func emitEntityClients(buf *bytes.Buffer, ent Entity) {
	name := ent.Name
	lower := strings.ToLower(name)
	columns := entityColumns(ent)
	returning := strings.Join(columns, ", ")
	insertSQL := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", pluralize(name), strings.Join(columns, ", "), placeholders(len(columns)), returning)
	selectSQL := fmt.Sprintf("SELECT %s FROM %s WHERE %s = $1", returning, pluralize(name), primaryColumn(ent))
	listSQL := fmt.Sprintf("SELECT %s FROM %s ORDER BY %s LIMIT $1 OFFSET $2", returning, pluralize(name), primaryColumn(ent))
	countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s", pluralize(name))

	updateCols := updatableColumns(ent)
	updateSQL := ""
	if len(updateCols) > 0 {
		assignments := make([]string, len(updateCols))
		for i, col := range updateCols {
			assignments[i] = fmt.Sprintf("%s = $%d", col, i+1)
		}
		updateSQL = fmt.Sprintf("UPDATE %s SET %s WHERE %s = $%d RETURNING %s", pluralize(name), strings.Join(assignments, ", "), primaryColumn(ent), len(updateCols)+1, returning)
	}

	fmt.Fprintf(buf, "const %sInsertQuery = `%s`\n", lower, insertSQL)
	fmt.Fprintf(buf, "const %sSelectQuery = `%s`\n", lower, selectSQL)
	fmt.Fprintf(buf, "const %sListQuery = `%s`\n", lower, listSQL)
	if updateSQL != "" {
		fmt.Fprintf(buf, "const %sUpdateQuery = `%s`\n", lower, updateSQL)
	}
	fmt.Fprintf(buf, "const %sCountQuery = `%s`\n", lower, countSQL)
	fmt.Fprintf(buf, "const %sDeleteQuery = `DELETE FROM %s WHERE %s = $1`\n\n", lower, pluralize(name), primaryColumn(ent))

	fmt.Fprintf(buf, "type %sClient struct {\n    db *pg.DB\n}\n\n", name)

	emitCreateMethod(buf, ent)
	emitByIDMethod(buf, ent)
	emitListMethod(buf, ent)
	emitCountMethod(buf, ent)
	if updateSQL != "" {
		emitUpdateMethod(buf, ent)
	}
	emitDeleteMethod(buf, ent)
}

func emitCreateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Create(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasDefaultNow || field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}

	for _, field := range ent.Fields {
		fieldName := exportName(field.Name)
		switch {
		case field.IsPrimary && field.Type == dsl.TypeUUID:
			fmt.Fprintf(buf, "    if input.%s == \"\" {\n", fieldName)
			fmt.Fprintf(buf, "        v, err := id.NewV7()\n")
			fmt.Fprintf(buf, "        if err != nil { return nil, err }\n")
			fmt.Fprintf(buf, "        input.%s = v\n", fieldName)
			fmt.Fprintf(buf, "    }\n")
		}
		if field.HasDefaultNow {
			fmt.Fprintf(buf, "    if input.%s.IsZero() { input.%s = now }\n", fieldName, fieldName)
		}
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", fieldName)
		}
	}

	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sInsertQuery", strings.ToLower(ent.Name))
	for _, field := range ent.Fields {
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ")\n")
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitByIDMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) ByID(ctx context.Context, id string) (*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sSelectQuery, id)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        if errors.Is(err, pgx.ErrNoRows) {\n            return nil, nil\n        }\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitListMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) List(ctx context.Context, limit, offset int) ([]*%s, error) {\n", ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if limit <= 0 { limit = 20 }\n")
	fmt.Fprintf(buf, "    if offset < 0 { offset = 0 }\n")
	fmt.Fprintf(buf, "    rows, err := c.db.Pool.Query(ctx, %sListQuery, limit, offset)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    if err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    defer rows.Close()\n")
	fmt.Fprintf(buf, "    var result []*%s\n", ent.Name)
	fmt.Fprintf(buf, "    for rows.Next() {\n        item := new(%s)\n        if err := rows.Scan(", ent.Name)
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&item.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n            return nil, err\n        }\n        result = append(result, item)\n    }\n")
	fmt.Fprintf(buf, "    if err := rows.Err(); err != nil { return nil, err }\n")
	fmt.Fprintf(buf, "    return result, nil\n}\n\n")
}

func emitCountMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Count(ctx context.Context) (int, error) {\n", ent.Name)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sCountQuery)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    var total int\n")
	fmt.Fprintf(buf, "    if err := row.Scan(&total); err != nil {\n        return 0, err\n    }\n")
	fmt.Fprintf(buf, "    return total, nil\n}\n\n")
}

func emitUpdateMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Update(ctx context.Context, input *%s) (*%s, error) {\n", ent.Name, ent.Name, ent.Name)
	fmt.Fprintf(buf, "    if input == nil {\n        return nil, errors.New(\"input cannot be nil\")\n    }\n")
	fmt.Fprintf(buf, "    if input.%s == \"\" {\n        return nil, errors.New(\"id is required\")\n    }\n", exportName(primaryField(ent).Name))

	needsNow := false
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			needsNow = true
			break
		}
	}
	if needsNow {
		fmt.Fprintf(buf, "    now := time.Now().UTC()\n")
	}
	for _, field := range ent.Fields {
		if field.HasUpdateNow {
			fmt.Fprintf(buf, "    input.%s = now\n", exportName(field.Name))
		}
	}

	updateCols := updatableColumns(ent)
	fmt.Fprintf(buf, "    row := c.db.Pool.QueryRow(ctx, %sUpdateQuery", strings.ToLower(ent.Name))
	for _, col := range updateCols {
		field := findFieldByColumn(ent, col)
		fmt.Fprintf(buf, ", input.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, ", input.%s)\n", exportName(primaryField(ent).Name))
	fmt.Fprintf(buf, "    out := new(%s)\n", ent.Name)
	fmt.Fprintf(buf, "    if err := row.Scan(")
	for i, field := range ent.Fields {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "&out.%s", exportName(field.Name))
	}
	fmt.Fprintf(buf, "); err != nil {\n        return nil, err\n    }\n")
	fmt.Fprintf(buf, "    return out, nil\n}\n\n")
}

func emitDeleteMethod(buf *bytes.Buffer, ent Entity) {
	fmt.Fprintf(buf, "func (c *%sClient) Delete(ctx context.Context, id string) error {\n", ent.Name)
	fmt.Fprintf(buf, "    _, err := c.db.Pool.Exec(ctx, %sDeleteQuery, id)\n", strings.ToLower(ent.Name))
	fmt.Fprintf(buf, "    return err\n}\n\n")
}

func entityColumns(ent Entity) []string {
	cols := make([]string, len(ent.Fields))
	for i, field := range ent.Fields {
		cols[i] = fieldColumn(field)
	}
	return cols
}

func placeholders(n int) string {
	items := make([]string, n)
	for i := 0; i < n; i++ {
		items[i] = fmt.Sprintf("$%d", i+1)
	}
	return strings.Join(items, ", ")
}

func primaryColumn(ent Entity) string {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return fieldColumn(field)
		}
	}
	return fieldColumn(ent.Fields[0])
}

func primaryField(ent Entity) dsl.Field {
	for _, field := range ent.Fields {
		if field.IsPrimary {
			return field
		}
	}
	return ent.Fields[0]
}

func updatableColumns(ent Entity) []string {
	cols := []string{}
	for _, field := range ent.Fields {
		if field.IsPrimary {
			continue
		}
		if field.HasDefaultNow && !field.HasUpdateNow {
			continue
		}
		cols = append(cols, fieldColumn(field))
	}
	return cols
}

func findFieldByColumn(ent Entity, column string) dsl.Field {
	for _, field := range ent.Fields {
		if fieldColumn(field) == column {
			return field
		}
	}
	return ent.Fields[0]
}

func fieldTypeLiteral(ft dsl.FieldType) string {
	switch ft {
	case dsl.TypeUUID:
		return "dsl.TypeUUID"
	case dsl.TypeString:
		return "dsl.TypeString"
	case dsl.TypeInt:
		return "dsl.TypeInt"
	case dsl.TypeFloat:
		return "dsl.TypeFloat"
	case dsl.TypeBool:
		return "dsl.TypeBool"
	case dsl.TypeBytes:
		return "dsl.TypeBytes"
	case dsl.TypeTime:
		return "dsl.TypeTime"
	case dsl.TypeJSON:
		return "dsl.TypeJSON"
	default:
		return fmt.Sprintf("dsl.FieldType(%q)", string(ft))
	}
}

func edgeKindLiteral(kind dsl.EdgeKind) string {
	switch kind {
	case dsl.EdgeToOne:
		return "dsl.EdgeToOne"
	case dsl.EdgeToMany:
		return "dsl.EdgeToMany"
	case dsl.EdgeManyToMany:
		return "dsl.EdgeManyToMany"
	default:
		return fmt.Sprintf("dsl.EdgeKind(%q)", string(kind))
	}
}

func mapLiteral(input map[string]any) string {
	if len(input) == 0 {
		return "nil"
	}
	keys := make([]string, 0, len(input))
	for k := range input {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	parts := make([]string, 0, len(keys))
	for _, key := range keys {
		parts = append(parts, fmt.Sprintf("%q: %#v", key, input[key]))
	}
	return fmt.Sprintf("map[string]any{%s}", strings.Join(parts, ", "))
}
