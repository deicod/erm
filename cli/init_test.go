package cli

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"
)

func TestInitCmdScaffoldsWorkspace(t *testing.T) {
	tmp := t.TempDir()

	wd, err := os.Getwd()
	if err != nil {
		t.Fatalf("getwd: %v", err)
	}
	t.Cleanup(func() {
		if chdirErr := os.Chdir(wd); chdirErr != nil {
			t.Fatalf("chdir back: %v", chdirErr)
		}
	})
	if err := os.Chdir(tmp); err != nil {
		t.Fatalf("chdir temp dir: %v", err)
	}

	cmd := newInitCmd()
	buf := &bytes.Buffer{}
	cmd.SetOut(buf)

	if err := cmd.RunE(cmd, []string{}); err != nil {
		t.Fatalf("run init: %v", err)
	}

	assertFileContains(t, "erm.yaml", "module: \"\"")
	assertFileContains(t, "erm.yaml", "postgis: false")
	assertFileContains(t, "erm.yaml", "pgvector: false")
	assertFileContains(t, "README.md", "This workspace was bootstrapped with 'erm init'")
	assertFileContains(t, "AGENTS.md", "Development Workflow")
	apiMain := filepath.Join("cmd", "api", "main.go")
	assertFileContains(t, apiMain, "package main")
	assertFileContains(t, apiMain, "github.com/your/module/graphql/server")
	assertFileContains(t, apiMain, "TODO: Set the module path")
	assertFileContains(t, apiMain, "resolveHTTPAddr")
	schemaAgents := filepath.Join("schema", "AGENTS.md")
	assertFileContains(t, schemaAgents, "Schema Development Workflow")
	assertFileContains(t, schemaAgents, "snake_case")
	assertFileContains(t, filepath.Join("graphql", "README.md"), "# GraphQL workspace")
	assertNoFile(t, filepath.Join("graphql", "directives", "auth.go"))
	assertNoFile(t, filepath.Join("graphql", "resolvers", "resolver.go"))
	composePath := filepath.Join("docker", "local", "compose.yaml")
	assertFileContains(t, composePath, "Generated by erm docker sync")
	extensionsSQL := filepath.Join("docker", "local", "initdb.d", "extensions.sql")
	assertFileContains(t, extensionsSQL, "Enable extensions in erm.yaml")

	if err := cmd.RunE(cmd, []string{}); err != nil {
		t.Fatalf("second init should be idempotent: %v", err)
	}

	if got := buf.String(); got == "" {
		t.Fatalf("expected init to print confirmation message")
	}
}

func TestInitCmdDefersRuntimeScaffoldsUntilModuleDetected(t *testing.T) {
	tmp := t.TempDir()
	modulePath := "github.com/example/app"

	wd, err := os.Getwd()
	if err != nil {
		t.Fatalf("getwd: %v", err)
	}
	t.Cleanup(func() {
		if chdirErr := os.Chdir(wd); chdirErr != nil {
			t.Fatalf("chdir back: %v", chdirErr)
		}
	})
	if err := os.Chdir(tmp); err != nil {
		t.Fatalf("chdir temp dir: %v", err)
	}

	goMod := "module " + modulePath + "\n\ngo 1.21\n"
	if err := os.WriteFile("go.mod", []byte(goMod), 0o644); err != nil {
		t.Fatalf("write go.mod: %v", err)
	}

	cmd := newInitCmd()
	if err := cmd.RunE(cmd, []string{}); err != nil {
		t.Fatalf("run init: %v", err)
	}

	resolverPath := filepath.Join("graphql", "resolvers", "resolver.go")
	assertFileContains(t, resolverPath, modulePath+"/graphql")
	assertFileContains(t, resolverPath, modulePath+"/orm/gen")
}

func assertFileContains(t *testing.T, path, substr string) {
	t.Helper()

	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("read %s: %v", path, err)
	}
	if !bytes.Contains(data, []byte(substr)) {
		t.Fatalf("file %s missing %q\ncontent:\n%s", path, substr, string(data))
	}
}

func assertNoFile(t *testing.T, path string) {
	t.Helper()

	if _, err := os.Stat(path); err == nil {
		t.Fatalf("expected %s to be absent", path)
	} else if !os.IsNotExist(err) {
		t.Fatalf("stat %s: %v", path, err)
	}
}
