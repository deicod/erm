# Customizing generated code safely

The generator is designed so that you can extend the runtime without hand-editing the files that are re-written on every `erm gen`.  Generated artifacts always carry the `// Code generated by erm. DO NOT EDIT.` header and end in `_gen.go`; anything outside of those files is treated as **yours**.  This guide collects the three main extension points you should reach for when adding behavior to an `erm` workspace:

1. Resolver hooks for GraphQL lifecycles.
2. Partial (non-generated) files that live next to `_gen.go` sources.
3. A predictable module layout that keeps hand-authored code in dedicated packages.

Together they let you run `erm gen` repeatedly without losing your changes.

---

## Resolver hooks

`erm graphql init` scaffolds `graphql/resolvers/entities_hooks.go`.  Unlike the generated resolver files, it does **not** include the generated warning because it is meant to be edited.  Populate the returned `entityHooks` struct with callbacks that run before or after the generated resolvers touch the ORM:

```go
// graphql/resolvers/entities_hooks.go
package resolvers

import (
    "context"
    "strings"

    "github.com/deicod/erm/graphql"
    "github.com/deicod/erm/orm/gen"
)

func newEntityHooks() entityHooks {
    return entityHooks{
        BeforeCreateUser: func(ctx context.Context, r *Resolver, input graphql.CreateUserInput, model *gen.User) error {
            // Mirror the behavior exercised in examples/blog by deriving a slug from the email.
            parts := strings.Split(input.Email, "@")
            if len(parts) > 0 {
                model.Slug = strings.ToLower(parts[0])
            }
            return nil
        },
        BeforeReturnUser: func(ctx context.Context, r *Resolver, record *gen.User) error {
            // Prime the dataloader cache with the ORM record before the GraphQL layer copies it.
            r.PrimeUser(ctx, record)
            record.DisplayName = strings.TrimSpace(record.DisplayName)
            return nil
        },
    }
}
```

On every `erm gen` run the generator refreshes `entities_gen.go` (which contains the hook wiring) but leaves `entities_hooks.go` untouched.  Tests such as `graphql/resolvers/hooks_test.go` assert the contract so that custom logic survives regeneration.

---

## Partial files alongside `_gen.go`

When you need helper methods, additional resolvers, or domain-specific validation, add new files next to the generated ones rather than editing them.  The generator respects any file that **does not** end in `_gen.go` and keeps it in place while refreshing its siblings.  Common examples include:

- `graphql/resolvers/mutation.resolvers.go` – ships empty so you can add bespoke mutations without forking the generated mutations file.
- `graphql/dataloaders/loader.go` – coordinates generated dataloaders and is safe to extend with custom lookups.
- `orm/runtime/validation/custom.go` – add runtime checks that reuse the generated predicate helpers.

Because Go packages compile from every `*.go` file in the directory, your partial files automatically link against the regenerated types.  This keeps business logic and generated plumbing in the same package without risking merge conflicts.

---

## Module layout for safe extensions

The repository layout intentionally separates hand-authored code from generated output:

- `orm/schema` holds the DSL definitions that drive regeneration.
- `orm/gen`, `graphql/models_gen.go`, and similar directories contain generated code only.
- `graphql/resolvers`, `graphql/dataloaders`, `cmd/server`, and `observability` are safe places to add modules that depend on the generated surface area.
- `examples/blog` mirrors the same layout so you can reference real customizations while developing new features.

Keeping custom logic in these non-generated packages means `erm gen` can overwrite its own output without touching your extensions.

---

## Putting it together (blog workspace excerpt)

The editorial workspace in `examples/blog` uses the pattern above to add behavior without ever editing `_gen.go` files:

1. Schema changes land in `examples/blog/schema/*.schema.go`.
2. A custom resolver lives in `graphql/resolvers/entities_hooks.go` and uses the hook shown above to normalize user profiles.
3. Shared helpers (for example, a `slug` package or validation helpers) sit in their own modules and are imported from the hook file.
4. Running `erm gen` updates the ORM, GraphQL models, and migrations; the hook stays intact and re-compiles automatically.

Whenever you introduce new behavior, start by asking "Can this live in a hook or partial file?"—if the answer is yes, your next regeneration will be safe.

---

## Checklist before regenerating

- Keep all manual edits in files **without** the `Code generated` banner.
- Run `go test ./...` to verify your custom packages still compile against the regenerated types.
- Re-run `erm gen` as often as needed; if the command reports everything as "up-to-date" you can commit immediately.

Following these rules keeps the ergonomics of code generation without giving up the ability to layer custom logic on top.
